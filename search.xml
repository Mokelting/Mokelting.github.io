<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树结构学习</title>
      <link href="/2023/09/18/shu-tree/"/>
      <url>/2023/09/18/shu-tree/</url>
      
        <content type="html"><![CDATA[<h1 align = center > 树 </h1><h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>树（Tree）是一种常见的数据结构，它具有分层结构，类似于自然界中的树，由节点（Node）和边（Edge）组成。每个树结构都包括一个根节点，该节点没有父节点，而其他节点通过边与根节点和其他节点相连。</p><p>树可以被称为递归数据结构</p><p>树结构有许多不同的应用，包括计算机科学中的数据存储、搜索、排序以及层次性组织等。</p><h3 id="树结构中的常见的术语和特性"><a href="#树结构中的常见的术语和特性" class="headerlink" title="树结构中的常见的术语和特性"></a>树结构中的常见的术语和特性</h3><ol><li><strong>根节点（Root）</strong>：树结构的顶部节点，<strong>没有父节点</strong>，它是树的起始点。</li><li><strong>子节点（Child）</strong>：树中的每个节点可以有<strong>零个或多个</strong>子节点，子节点是其父节点的直接下级节点。</li><li><strong>父节点（Parent）</strong>：每个节点<strong>除了根节点</strong>外，都有一个父节点，它是其子节点的直接上级节点。</li><li><strong>叶子节点（Leaf）</strong>：<strong>没有子节点</strong>的节点称为叶子节点，它们位于树结构的末端 。</li><li><strong>兄弟节点（Sibling）</strong>：<strong>具有相同父节点</strong>的节点称为兄弟节点。</li><li><strong>节点的度</strong>：一个节点包含的子树的个数即为该节点的度</li><li><strong>树的度</strong>：所有节点的度当中的最大值</li><li><strong>节点的层次</strong>：根节点层次为1，以此递增</li><li><strong>深度（Depth）</strong>：从根节点到某个节点的路径上的边数称为该节点的深度。根节点的深度为0。</li><li><strong>高度（Height）</strong>：树结构中任意节点的最长路径（边数）称为树的高度。树的高度通常以根节点为参考。</li><li><strong>子树（Subtree）</strong>：树中的任何节点和其所有后代节点（包括该节点本身）构成的子树。</li><li><strong>有向边（Directed Edge）</strong>：连接两个节点的边<strong>具有方向</strong>，从一个节点指向另一个节点。</li></ol><h3 id="常见的树类型"><a href="#常见的树类型" class="headerlink" title="常见的树类型"></a>常见的树类型</h3><ol><li><p><strong>二叉树（Binary Tree）</strong>：每个节点最多有两个子节点，左子节点和右子节点。</p></li><li><p><strong>二叉搜索树（Binary Search Tree）</strong>：二叉树的一种，具有特定的排序规则，左子树的所有节点值小于根节点的值，右子树的所有节点值大于根节点的值。</p></li><li><p><strong>平衡二叉树（Balanced Binary Tree）</strong>：一种二叉搜索树，具有平衡性质，确保树的高度较低，提高了搜索等操作的效率。</p></li><li><p><strong>B树和B+树</strong>：用于在磁盘上高效存储和检索数据的树状数据结构，常见于数据库管理系统中。</p></li><li><p><strong>树堆（Heap）</strong>：一种特殊的树结构，用于高效查找和删除最大或最小值的元素，通常用于堆排序和优先队列。</p></li><li><p><strong>树结构的图形表示</strong>：树结构通常可以以树状图的方式进行可视化表示，根节点在顶部，子节点向下延伸。</p></li></ol><p>树结构是计算机科学中的重要数据结构之一，它们用于解决各种问题，包括数据存储、搜索、排序、编译器中的语法分析、操作系统中的文件系统等等。了解树结构的基本概念和特性对于编写高效的算法和解决问题非常重要。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树中的许多操作的时间开销取决于树的高度，因此总希望二叉树的高度尽可能的小</p><p>二叉树的三种遍历：</p><ul><li>前序遍历——先后访问根节点、左子树、右子树</li><li>中序遍历——先后访问左子树、根节点、右子树</li><li>后序遍历——先后访问左子树、右子树、根节点</li></ul><p>三序的遍历有更加直观易记的方法 <a href="https://www.bilibili.com/video/BV1Ub4y147Zv/?spm_id_from=333.337.search-card.all.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">无脑画点连线法，一学就会</a> 作者：<a href="https://space.bilibili.com/446171901">阿琛w</a></p><p>具体思路：</p><p>对于任意一颗树而言，前序遍历的形式总是<br>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是<br>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p><p>已知其中xx和xx序，推测第三种yy序：</p><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。</p><p>由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>细节</p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希映射（HashMap）来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p><p>————————————————<br>版权声明：本文为CSDN博主「看，未来」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43762191/article/details/107280503">种树：二叉树、二叉搜索树、AVL树、红黑树、哈夫曼树、B树、树与森林</a></p><p>————————————————</p><p>作者：LeetCode-Solution<br>原文链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">从前序与中序遍历序列构造二叉树</a></p><h2 id="完整二叉树（Complete-Binary-Tree）"><a href="#完整二叉树（Complete-Binary-Tree）" class="headerlink" title="完整二叉树（Complete Binary Tree）"></a>完整二叉树（Complete Binary Tree）</h2><p>完整二叉树（Complete Binary Tree）是一种二叉树，其中每一层都被完全填充，<strong>除了最后一层</strong>可能不是满的，但是最后一层的所有节点都<strong>集中在该层的左侧</strong>。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li>所有叶子节点都出现在最后一层或倒数第二层。</li><li>如果有子节点，每个节点都有两个子节点。</li><li>最后一层的节点都尽可能地靠左排列。</li></ol><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><pre class=" language-html"><code class="language-html">      1    /   \   2     3  / \   / 4   5 6</code></pre><h2 id="完美二叉树（Perfect-Binary-Tree）"><a href="#完美二叉树（Perfect-Binary-Tree）" class="headerlink" title="完美二叉树（Perfect Binary Tree）"></a>完美二叉树（Perfect Binary Tree）</h2><p>完美二叉树（Perfect Binary Tree），也被称为满二叉树（Full Binary Tree），是一种特殊类型的二叉树</p><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ol><li>每个非叶子节点都有两个子节点。</li><li>所有叶子节点都在同一层级上，也就是说，树的<strong>所有层级都被完全填充</strong>。</li></ol><p>这意味着在完美二叉树中，每一层都包含最大数量的节点，即每一层的节点数都是2的幂次方。完美二叉树的高度（深度）通常由叶子节点的层级决定，如果有h层，则叶子节点位于第h层，树的高度为h。</p><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><pre><code>        1      /   \     2     3    / \   / \   4   5 6   7</code></pre><h2 id="二叉搜索树（Binary-Search-Tree，BST）"><a href="#二叉搜索树（Binary-Search-Tree，BST）" class="headerlink" title="二叉搜索树（Binary Search Tree，BST）"></a>二叉搜索树（Binary Search Tree，BST）</h2><p>二叉搜索树（Binary Search Tree，BST）是一种二叉树的特殊形式。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>每个节点都包含一个值（通常是一个可比较的值），并且这些值按照特定的顺序排列。</li><li>对于每个节点：<ul><li>所有左子树中的节点的值都小于该节点的值。</li><li>所有右子树中的节点的值都大于该节点的值。</li><li>左右子树都是二叉搜索树。</li><li>每个节点的左右子树也是BST</li></ul></li><li>左子树的每一个节点的键值一定小于右子树每一个节点的键值（即右子树最小的键值）</li></ol><p>这个特性使得二叉搜索树非常适合进行快速的搜索、插入和删除操作，因为它充分利用了值的相对大小来构建树结构。如果树的结构是平衡的，搜索、插入和删除操作的时间复杂度通常为O(log n)，其中n是树中节点的数量。</p><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><pre><code>        5       / \      3   8     / \ / \    1  4 7  9</code></pre><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>需要注意的是，如果二叉搜索树的<strong>结构不平衡</strong>，即左子树和右子树的高度差异很大，搜索操作的性能可能会退化到O(n)，其中n是树中节点的数量。在极限情况下可能退化成链表（重新变成线性结构）</p><h3 id="BST常见操作："><a href="#BST常见操作：" class="headerlink" title="BST常见操作："></a>BST常见操作：</h3><h4 id="1、查找（搜索）："><a href="#1、查找（搜索）：" class="headerlink" title="1、查找（搜索）："></a>1、查找（搜索）：</h4><p>采取递归式搜索：</p><ol><li>value &lt; root，则向根节点左侧向下搜索</li><li>value &gt; root，则向根节点右侧向下搜索</li><li>当root为空或&#x3D;&#x3D;value时，直接返回为空或者返回根节点的值</li></ol><h4 id="2、插入："><a href="#2、插入：" class="headerlink" title="2、插入："></a>2、插入：</h4><p>新元素进入后，遇到大于的键值val的向左走，小于键值val的向右走，一直到尾端</p><h4 id="3、删除："><a href="#3、删除：" class="headerlink" title="3、删除："></a>3、删除：</h4><p>假设删除A节点</p><ol><li>A的度为0（叶节点）：直接移除A</li><li>A的度为1：A节点的节点直接补上</li><li>A的度为2：将A节点右子树键值最小的节点补上</li></ol><h2 id="平衡二叉树（Balanced-Binary-Tree）"><a href="#平衡二叉树（Balanced-Binary-Tree）" class="headerlink" title="平衡二叉树（Balanced Binary Tree）"></a>平衡二叉树（Balanced Binary Tree）</h2><p>平衡二叉树（Balanced Binary Tree），也称为平衡二叉搜索树（Balanced Binary Search Tree），是一种特殊类型的二叉搜索树（BST），因二叉搜索树的查找效率取决于树的高度，因而进一步提出而平衡二叉搜索树来保持树的高度达到最小。</p><h3 id="E-p："><a href="#E-p：" class="headerlink" title="E.p："></a>E.p：</h3><p>当输入序列 {1，2，3，4，5，6}，仍使用普通的二叉搜索树会退化成单链表：</p><p><img src="https://img-blog.csdnimg.cn/20200711144946466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img"></p><p>但使用平衡二叉搜索树则是：当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。这种左右子树的高度相差不超过1的树为平衡二叉树。</p><p><img src="https://img-blog.csdnimg.cn/20200711145115978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>每个节点都包含一个值（通常是可比较的值）。</li><li>对于每个节点：<ul><li>左子树和右子树的高度之差（平衡因子）最多为1。</li><li>左右子树都是平衡二叉树。</li></ul></li></ol><p>平衡二叉树的关键特性是它的高度相对较低，因此搜索、插入和删除操作的时间复杂度通常是O(log n)，其中n是树中节点的数量。</p><h3 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h3><pre><code>        4       / \      2   6     / \ / \    1  3 5  7</code></pre><h3 id="AVL树的构造："><a href="#AVL树的构造：" class="headerlink" title="AVL树的构造："></a>AVL树的构造：</h3><p>由上图可知：插入62节点之后，先进行普通的BST的插入，此时左子树高度为1，右子树高度为3，平衡因子的绝对值 &#x3D;&#x3D; 2，树失衡则需进行旋转操作：</p><h4 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h4><h4 id="左旋（LL平衡旋转）操作的步骤："><a href="#左旋（LL平衡旋转）操作的步骤：" class="headerlink" title="左旋（LL平衡旋转）操作的步骤："></a>左旋（LL平衡旋转）操作的步骤：</h4><ol><li>设定一个不平衡的节点为X，其右子树的高度比左子树高度高。</li><li>将X的右子节点Y取出，并将Y的左子节点B连接到X的右子节点。</li><li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点，以保持树的连接。</li><li>最后，将X连接到Y的左子节点B上。</li></ol><p>左旋操作后，X会变成Y的左子节点，而Y会成为X的父节点，从而保持了树的平衡性。</p><p>一直遍历，直到找到平衡因子的绝对值不为1的节点进行旋转操作。</p><p><strong>40</strong>的右节点<strong>51</strong>的左节点<strong>46</strong>接到<strong>40</strong>的右节点，而后将<strong>40</strong>这一节点接到<strong>51</strong>的左节点，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/2020071115165424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200711151718338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="右旋（RR平衡旋转）操作的步骤如下："><a href="#右旋（RR平衡旋转）操作的步骤如下：" class="headerlink" title="右旋（RR平衡旋转）操作的步骤如下："></a>右旋（RR平衡旋转）操作的步骤如下：</h4><ol><li>设定一个不平衡的节点为X，其左子树的高度比右子树高度高。</li><li>将X的左子节点Y取出，并将Y的右子节点B连接到X的左子节点。</li><li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点。</li><li>最后，将X连接到Y的右子节点B上。</li></ol><p>右旋操作后，X会变成Y的右子节点，而Y会成为X的父节点，也能够保持树的平衡性。</p><p>A处的节点左右失衡，找到失衡节点的左节点B，将B的右节点E和B断开，接入A的左节点，而后将A接入到B的右节点。</p><p><img src="https://img-blog.csdnimg.cn/20200711154951407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200711155008636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="双旋转（不平衡节点在内侧）"><a href="#双旋转（不平衡节点在内侧）" class="headerlink" title="双旋转（不平衡节点在内侧）"></a>双旋转（不平衡节点在内侧）</h4><h4 id="先左后右双旋转（LR平衡旋转）"><a href="#先左后右双旋转（LR平衡旋转）" class="headerlink" title="先左后右双旋转（LR平衡旋转）"></a>先左后右双旋转（LR平衡旋转）</h4><p>左孩子右子树上插入新的节点，导致的不平衡</p><p><img src="C:\Users\moru\AppData\Roaming\Typora\typora-user-images\image-20230918112359944.png" alt="image-20230918112359944"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
