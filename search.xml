<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从零开始的Java</title>
      <link href="/2023/10/12/cong-ling-kai-shi-de-java/"/>
      <url>/2023/10/12/cong-ling-kai-shi-de-java/</url>
      
        <content type="html"><![CDATA[<h1 align = center> JAVA </h1><h2 id="字面量："><a href="#字面量：" class="headerlink" title="字面量："></a>字面量：</h2><p><img src="E:\DeskTable\博客学习截图传输\image-20230921152649653.png" alt="image-20230921152649653"></p><h2 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h2><p>栈：方法运行时使用内存</p><p>堆：存储数据和对象以及new创建的对象和数据，new多少次开辟几次空间</p><p>方法区：存储可执行的class文件</p><p>本地方法栈：JVM使用操作系统功能时使用</p><p>寄存器：CPU调度使用</p><img src="E:\DeskTable\博客学习截图传输\image-20231006111238285.png" alt="image-20231006111238285" style="zoom: 50%;" /><p>JDK8以后：</p><p>栈</p><p>堆</p><p>元空间</p><p>本地方法栈</p><p>寄存器</p><img src="E:\DeskTable\博客学习截图传输\image-20231006111224616.png" alt="image-20231006111224616" style="zoom:50%;" />  <h3 id="阿里的检查插件"><a href="#阿里的检查插件" class="headerlink" title="阿里的检查插件"></a>阿里的检查插件</h3><p><a href="https://blog.csdn.net/lizz861109/article/details/109027594">idea安装阿里代码检查工具（Alibaba Java Coding Guidelines）_alibaba java coding guidelines plugin support.-CSDN博客</a></p><p>Java 本身有数组对象,new一个数组对象,也是固定的大小,插删</p><p>使用了一个集合类型，可能存在内存泄漏</p><p>直接销毁集合对象，但是集合内的数据尚未释放</p><p>Java 底层并没有泛型概念，是后期拓展出的功能</p><p>异常处理！！！实际项目很重要</p><h1 id="抽象类和-接口"><a href="#抽象类和-接口" class="headerlink" title="抽象类和&#x3D;&#x3D;接口&#x3D;&#x3D;"></a>抽象类和&#x3D;&#x3D;接口&#x3D;&#x3D;</h1><p>Java只支持单继承</p><p>对比：</p><ul><li>c++有纯虚函数的概念：函数原型——函数的声明和实现分离</li><li>Java没有</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的离散数学</title>
      <link href="/2023/10/12/chi-san-shu-xue/"/>
      <url>/2023/10/12/chi-san-shu-xue/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的大学物理</title>
      <link href="/2023/10/11/da-xue-wu-li/"/>
      <url>/2023/10/11/da-xue-wu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="14章-静电场"><a href="#14章-静电场" class="headerlink" title="14章 静电场"></a>14章 静电场</h1><h2 id="14-1-电荷-库仑定律"><a href="#14-1-电荷-库仑定律" class="headerlink" title="14-1 电荷 库仑定律"></a>14-1 电荷 库仑定律</h2><h3 id="1-电荷量子化"><a href="#1-电荷量子化" class="headerlink" title="1. 电荷量子化"></a>1. 电荷量子化</h3><ol><li><p>种类：正电荷、负电荷</p></li><li><p>性质：同性相斥、异性相吸</p></li><li><p>单位：库伦（C）</p></li><li><p>量子化： $q&#x3D;\pm ne$ </p><p>​   $e&#x3D;1.602\times10^{-19}$</p></li></ol><h3 id="2-电荷守恒定律："><a href="#2-电荷守恒定律：" class="headerlink" title="2. 电荷守恒定律："></a>2. 电荷守恒定律：</h3><p>不管系统中的电荷如何迁移，孤立系统的电荷的代数和保持不变（自然界的基本守恒定律之一）</p><h4 id="3-库仑定律："><a href="#3-库仑定律：" class="headerlink" title="3. 库仑定律："></a>3. 库仑定律：</h4><ul><li><p>真空中两个静止点电荷 相互作用力<strong>F</strong>的大小与这两个点电荷所带电荷 量 $q_1$ 和 $q_2$ 的乘积成正比， 与它们之间的距离<strong>r</strong>的平 方成反比</p></li><li><p>点电荷：抽象模型</p></li><li><p>库仑力大小为: $F &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{q_1q_2}{r^2}$ 方向:同号相斥,异号相吸 </p></li><li><p>真空电容率: $\epsilon_0 &#x3D; 8.85\times10^{-12} C^2\cdot m^{-2}$ </p></li><li><p>两个以上的静止点电荷采用<strong>静电力的叠加原理</strong>:</p><ul><li>作用于每一个电荷上的总静电力等于其他点电荷单独存在时作 用于该电荷的静电力的矢量和。</li><li><img src="E:\DeskTable\博客学习截图传输\image-20231011095200807.png" alt="image-20231011095200807" style="zoom:67%;" /></li></ul></li></ul><h2 id="14-2-电场-电场强度"><a href="#14-2-电场-电场强度" class="headerlink" title="14-2 电场 电场强度"></a>14-2 电场 电场强度</h2><h3 id="1-静电场"><a href="#1-静电场" class="headerlink" title="1. 静电场"></a>1. 静电场</h3><img src="E:\DeskTable\博客学习截图传输\image-20231011095349585.png" alt="image-20231011095349585" style="zoom:50%;" /><h3 id="2-电场强度"><a href="#2-电场强度" class="headerlink" title="2. 电场强度"></a>2. 电场强度</h3><ul><li><p>电场中某点处的电场强度等于位于该点处的单位试验电荷 所受的力，其<strong>方向为正电荷受力方向</strong>.</p></li><li><p>电场强度大小:$E&#x3D;\frac{F}{q_0}$ </p></li><li><p>单位: $N \cdot C^{-1}$ 或 $V \cdot m^{-1}$ </p></li><li><p>电荷在电场中受力: $F&#x3D;qE$</p></li></ul><h3 id="3-点电荷电场强度"><a href="#3-点电荷电场强度" class="headerlink" title="3. 点电荷电场强度"></a>3. 点电荷电场强度</h3><p>知识点和高中相似</p><p>$F &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{Qq_0}{r^2}$$E &#x3D; \frac{F}{q_0} &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{Q}{r^2}$</p><h3 id="4-电场强度叠加原理"><a href="#4-电场强度叠加原理" class="headerlink" title="4. 电场强度叠加原理"></a>4. 电场强度叠加原理</h3><p>4-1 点电荷$q_i$ 对 $q_0$ ,在$q_0$ 处的总电场强度:</p><ul><li>与静电力的叠加原理类似,某个电荷之外的其他电荷在该电荷的电场等于每一个电场强度的矢量和:</li><li>$\vec{E} &#x3D; \sum_i \vec{E_i} $</li></ul><p>4-2 连续电荷在某一点的总电场强度:</p><img src="E:\DeskTable\博客学习截图传输\image-20231011100812868.png" alt="image-20231011100812868" style="zoom:50%;" /><p>$d\vec{E} &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r}$$\vec{E} &#x3D; \int d \vec{E} &#x3D; \int \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r} $</p><p>体密度: $\rho &#x3D; \frac{dq}{dV}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011101609517.png" alt="image-20231011101609517" style="zoom:50%;" /></p><p>面密度: $\sigma &#x3D; \frac{dq}{dS}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011101549342.png" alt="image-20231011101549342" style="zoom: 50%;" /></p><p>线密度: $ \lambda &#x3D; \frac{dq}{dl} $ <img src="E:\DeskTable\博客学习截图传输\image-20231011101526062.png" alt="image-20231011101526062" style="zoom: 50%;" /></p><h3 id="5-外电场对电偶极子的力矩和取向作用"><a href="#5-外电场对电偶极子的力矩和取向作用" class="headerlink" title="5. 外电场对电偶极子的力矩和取向作用"></a>5. 外电场对电偶极子的力矩和取向作用</h3><img src="E:\DeskTable\博客学习截图传输\image-20231011101656283.png" alt="image-20231011101656283" style="zoom:150%;" /><p>相距很近,等量异号的点电荷系:</p><p>​电距: $\vec{P} &#x3D; q \vec{l} $</p><img src="E:\DeskTable\博客学习截图传输\image-20231011102016383.png" alt="image-20231011102016383" style="zoom: 67%;" /><p>匀强电场中:</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231011102128247.png" alt="image-20231011102128247"></p><p>$\vec{F} &#x3D; \vec{F_+} + \vec{F_-} &#x3D; q\vec{E} - q\vec{E} &#x3D; 0$</p><p>$M &#x3D; q r_0 E \sin{\theta} &#x3D; pE\sin{\theta}$ </p><p>$\vec{M} &#x3D; \vec{p} \times \vec{E} \left{<br>\begin{array}{l}<br>\theta &#x3D; 0 \<br>\theta &#x3D; \pi<br>\end{array}<br>\right.$$\vec{M} &#x3D; 0$</p><h2 id="14-3-电场强度通量-高斯定理"><a href="#14-3-电场强度通量-高斯定理" class="headerlink" title="14-3 电场强度通量 高斯定理"></a>14-3 电场强度通量 高斯定理</h2><h3 id="1-电场线"><a href="#1-电场线" class="headerlink" title="1. 电场线"></a>1. 电场线</h3><p>为了直观可视化描述电场</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231011103714950.png" alt="image-20231011103714950"></p><ul><li>曲线上每一点切线方向为该点电场方向</li><li>通过垂直于电场方向单位面积的电场线的条数为该电场强度的大小      $|\vec{E}| &#x3D; E &#x3D; \frac{dN}{dS_{\perp}}$</li></ul><p>多种点电荷电场线,与高中无异</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>始于正电荷,终于负电荷(来自无穷远,去向无穷远) 在没有电荷的地方不中断</li><li>没有电荷的地方任意两条电场线不相交</li><li>电场线不闭合</li><li>电场线密集——电场强度较大；电场线稀疏——电场强度较小</li></ol><h3 id="2-电场强度通量"><a href="#2-电场强度通量" class="headerlink" title="2. 电场强度通量"></a>2. 电场强度通量</h3><p>通过电场中某一个面的电场线数叫做通过这个面的电场强度通量</p><ul><li><p>匀强电场:</p><ul><li><p>$\vec{E}$ 与平面垂直</p><p>$\Phi_e &#x3D; ES$ <img src="E:\DeskTable\博客学习截图传输\image-20231011104246049.png" alt="image-20231011104246049"  /> </p></li><li><p>$\vec{E} $ 与平面夹角为$\theta$<br>$\Phi_e &#x3D; ES \cos{\theta} $$\Phi_e &#x3D; \vec{E} \cdot \vec{S}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011104550268.png" alt="image-20231011104550268"></p></li></ul></li><li><p>非均匀电场</p><ul><li><p>$ d \vec{S} &#x3D; dS \cdot \vec{e_n}$</p></li><li><p>$ d\Phi_e &#x3D; \vec{E} \cdot d \vec{S} $</p></li><li><p>$ \Phi_e &#x3D; \int d \Phi_e &#x3D; \int_S E \cos{\theta} dS $</p></li><li><p>$ \Phi_e &#x3D; \int_S \vec{E} \cdot d\vec{S} $</p></li><li><p><img src="E:\DeskTable\博客学习截图传输\image-20231011105921724.png" alt="image-20231011105921724"></p></li><li><p>S为封闭曲面时:</p><ul><li><p>$\theta_1 &lt; \frac{\pi}{2} , d\Phi_{e1} &gt; 0 $</p></li><li><p>$ \theta_2 &gt; \frac{\pi}{2}, d\Phi_{e2} &lt; 0$</p></li><li><p><img src="E:\DeskTable\博客学习截图传输\image-20231011105912608.png" alt="image-20231011105912608"></p></li></ul></li><li><p>闭合曲面的电场强度通量</p><ul><li>$ d\Phi_e &#x3D; \vec{E} \cdot d \vec{S} $</li><li>$ \oint_S \vec{E} \cdot d \vec{S} &#x3D; \oint_S E \cos{\theta} dS $</li><li><img src="E:\DeskTable\博客学习截图传输\image-20231011105852809.png" alt="image-20231011105852809"></li></ul></li></ul></li></ul><h3 id="3-高斯定理"><a href="#3-高斯定理" class="headerlink" title="3. 高斯定理"></a>3. 高斯定理</h3><p>在真空中,通过任一闭合曲面的电场强度通量, 等于该曲面所包围的所有电荷的代数和除以 $\epsilon_0$ （与面外电荷无关，闭合曲面称为高斯面）</p><p>$ \Phi_e &#x3D; \oint_S \vec{E} \cdot d \vec{S} &#x3D; \frac{1}{\epsilon_0} \sum^n_{i&#x3D;1} q_i^{in}$  </p><p>由<strong>库仑定律</strong>和<strong>电场强度叠加原</strong>理可以导出<strong>高斯定理</strong></p><ul><li><p>闭合面外的电荷对通过闭合 面的电场强度通量没有贡献，但是对闭合面上各点的电场强度是有贡献的，即闭合面上各点的电场强度是由闭合面内、外所有电 荷共同激发的</p></li><li><p>高斯定理将静电场与场源电荷联系了起来，揭示了静电场是有源场这一普遍性质(静电场有源无旋)</p></li></ul><h3 id="4-高斯定理的应用"><a href="#4-高斯定理的应用" class="headerlink" title="4. 高斯定理的应用"></a>4. 高斯定理的应用</h3><p>应用条件:</p><ol><li><p>静电场必须具有一定的对称性</p></li><li><p>根据对称性选择高斯面</p></li><li><p>高斯面上的场强处处相等或者分区域相等;</p><p>部分高斯面上的通量为零,部分高斯面上的场强相等</p></li><li><p>先使用高斯定理求出电场强度通量,而后用高斯定理,配合闭合曲面大小求出电场强度</p></li></ol><h2 id="14-4-静电场的环路定理-电势"><a href="#14-4-静电场的环路定理-电势" class="headerlink" title="14-4 静电场的环路定理 电势"></a>14-4 静电场的环路定理 电势</h2><h4 id="1-静电场力所做的功"><a href="#1-静电场力所做的功" class="headerlink" title="1. 静电场力所做的功"></a>1. 静电场力所做的功</h4><p>点电荷的电场</p><p>$dA &#x3D; q_0 \vec{E} \cdot \vec{l} &#x3D; q_0E \cdot dl \cdot \cos{\theta} $</p><p>​  $&#x3D;q_0 \frac{q}{4 \pi \epsilon_0 r^2} \cdot dl \cdot \cos{\theta} $</p><p>$dl \cos{\theta} &#x3D; dr$</p><p>$dA &#x3D; \frac{q_0q}{4 \pi \epsilon_0 r^2} dr$</p><p>$A&#x3D; \frac{q_0q}{4 \pi \epsilon_0} \int^{r_B}_{r_A} \frac{dr}{r^2} &#x3D; \frac{q_0q}{4 \pi \epsilon_0}(\frac{1}{r_A} - \frac{1}{r_B})$</p><p>所做的功<strong>A</strong> 仅和 $q_0$ 的始末位置有关,与路径无关(积分与路径无关)</p><p>即可得:</p><p>$ \vec{E} &#x3D; \sum \vec{E_i} $ (点电荷的组合)</p><p>$ A &#x3D; \int_l q_0 \vec{E} \cdot d \vec{l} &#x3D; \sum_i q_0 \cdot \int_l \vec{E_i} \cdot d \vec{l} $</p><img src="E:\DeskTable\博客学习截图传输\image-20231011121105020.png" alt="image-20231011121105020" style="zoom: 67%;" /><h4 id="2-静电场的环路定理"><a href="#2-静电场的环路定理" class="headerlink" title="2. 静电场的环路定理"></a>2. 静电场的环路定理</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20231011123130536.png" alt="image-20231011123130536"></p><p>$ q_0 \int_{ABC} \vec{E} \cdot d \vec{l} &#x3D; q_0 \int_{ADC} \cdot d \vec{l} $</p><p>$ q_0(\int_{ABC} \vec{E} \cdot d \vec{l} - \int_{ADC} \vec{E} \cdot d \vec{l}) &#x3D; 0 $</p><p>静电场是保守场,沿闭合路径一周,电场力做功为零</p><h1 id="16章-稳恒磁场"><a href="#16章-稳恒磁场" class="headerlink" title="16章 稳恒磁场"></a>16章 稳恒磁场</h1><h2 id="16-1"><a href="#16-1" class="headerlink" title="16-1"></a>16-1</h2><h3 id="1-电流电流密度"><a href="#1-电流电流密度" class="headerlink" title="1. 电流电流密度"></a>1. 电流电流密度</h3><h4 id="1-1形成电流的条件："><a href="#1-1形成电流的条件：" class="headerlink" title="1.1形成电流的条件："></a>1.1形成电流的条件：</h4><ul><li><p>在导体内有可以自由移动的电荷（载流子） </p></li><li><p>在导体内要维持一个电场，或者在导体两端要存在有电势差\</p></li></ul><p><img src="E:\DeskTable\博客学习截图传输\image-20231011192022160.png" alt="image-20231011192022160"></p><p>电流强度：通过截面<strong>S</strong>的电荷随时间的变化率</p><p>$I &#x3D; \frac{dq}{dt} $</p><p>$dq &#x3D; qnudtS$ </p><ul><li>$q$ 载流子电荷</li><li>$n$ 载流子浓度 </li><li>$\vec{u}$ 载流子漂移速度 $u$ 电子漂移速度的大小</li></ul><p>$dI &#x3D; qnudS_{\perp} &#x3D; qnudS \cos{theta} &#x3D; qn \vec{u} \cdot d \vec{S} &#x3D; \vec{j} \cdot \textbf{d} \vec{S} $  </p><p>电流密度矢量大小: $j &#x3D; \frac{dI}{d S_{\perp}} &#x3D; qnu$ 方向为该点正电荷运动方向,单位: $A \cdot m^{-2}$ </p><p>通过任意曲面的电流: $I &#x3D; \int_S \vec{j} \cdot d \vec{S}$ </p><h4 id="1-2-电流的连续性方程稳恒电流条件"><a href="#1-2-电流的连续性方程稳恒电流条件" class="headerlink" title="1.2 电流的连续性方程稳恒电流条件"></a>1.2 电流的连续性方程稳恒电流条件</h4><p>单位时间内通过闭合曲面向外流出的电荷，等于此时间内闭合曲面内电荷的减少量.</p><p>电流密度矢量点乘闭合曲面面积矢量微元即是此刻在该处曲面的电流的微元</p><p>$ dI &#x3D; \vec{j} \cdot d \vec{S}$ $I &#x3D; \oint_S \vec{j} \cdot d \vec{S} &#x3D; \frac{dq_外}{dt} &#x3D; -\frac{dq_内}{dt} $</p><p>某一时刻,单位闭合曲面 <em>S</em> 内,流入的电荷量与流出的电荷量相互抵消——即闭合曲面 <em>S</em> 内部的电荷不随时间的变化而变化，则</p><p>$ \frac{d q_内}{dt} &#x3D; 0$ </p><p>稳恒电流$ \oint_S \vec{j} \cdot d \vec{S} &#x3D; 0$ </p><p>导体内的电流密度不随时间变化的电流</p><img src="E:\DeskTable\博客学习截图传输\image-20231011201203610.png" alt="image-20231011201203610" style="zoom:50%;" /><p>由基尔霍夫第一定律:$ -I+I_1+I_2&#x3D;0 $ </p><ol><li>在稳恒电流情况下，导体中电荷分布不随时间变化形成恒定电场</li><li>稳恒电场与&#x3D;&#x3D;静电场具有相似性质&#x3D;&#x3D;（高斯定理和环路定理），同时稳恒电场引入了电势概念</li><li>稳恒电场存在&#x3D;&#x3D;能量的转换&#x3D;&#x3D;（很正常，带电体在电场内会做功或者被做功，则必然伴随着$势能 \rightleftharpoons 动能$）</li></ol><p>$U &#x3D; IR$ $R &#x3D; \rho \frac{l}{s}$</p><h4 id="1-3-欧姆定律的微分形式"><a href="#1-3-欧姆定律的微分形式" class="headerlink" title="1.3 欧姆定律的微分形式"></a>1.3 欧姆定律的微分形式</h4><img src="E:\DeskTable\博客学习截图传输\image-20231012000103917.png" alt="image-20231012000103917" style="zoom:67%;" /><p>$dI &#x3D; \frac{dU}{R}$$R &#x3D; \frac{\rho dl}{dS} $</p><p>$dI &#x3D; \frac{1}{\rho} \frac{dU}{dl} dS$</p><p>$\frac{dI}{dS} &#x3D; \frac{1}{\rho} \frac{dU}{dl} &#x3D; \frac{1}{\rho} E &#x3D; \sigma E$</p><p>$\vec{j} &#x3D; \frac{dI}{dS} &#x3D; \frac{1}{\rho} \vec{E} &#x3D; \sigma \vec{E}$</p><p>非静电力：能不断分离正负电荷使正电荷逆静电场力方向运动</p><p>电源：提供非静电力的装置</p><p>非静电电场强度 $\vec{E_k}$ : 为单位正电荷所受的非静电力.</p><p>$A_非 &#x3D; \int^+_- q \vec{E_k} \cdot d \vec{l} $</p><p>电动势的定义：单位正电荷从负极通过电源内部移到正极时非静电力所做的功.</p><p>电动势是电路中电荷流动的驱动力</p><img src="E:\DeskTable\博客学习截图传输\image-20231012081945376.png" alt="image-20231012081945376" style="zoom:50%;" /><p>计算电动势的两种不同描述:</p><ol><li><p>基于电荷在已知电场中的移动</p><ul><li>这个公式表示了电场 $\vec{E_k}$ 在电荷 $q$ 移动的路径上执行的功，然后将这个功除以电荷的大小 $q$，得到电动势 $\epsilon$。这是电动势的一种定义方式，其中 $\vec{E_k}$ 是电场力，$d\vec{l}$ 是电荷移动路径上的微小位移，而 $\int_{+}^{-}$ 表示要对电荷从一个点移动到另一个点的路径上进行积分。</li><li>$ \epsilon &#x3D; \frac{A_非}{q} &#x3D; \int^+_- \vec{E_k} \cdot d \vec{l}$</li></ul><p></p></li><li><p>考虑电荷周围存在其他电场情况</p><ul><li>这个公式表示电场 $\vec{E_k}$ 和一个额外电场 $\vec{E}$ 一起对电荷 $q$ 执行的功的总和。在这里，$\vec{E_k}$ 是由于电荷本身产生的电场，而 $\vec{E}$ 可能是由外部因素产生的电场，如其他电荷或电场源。这个公式采用了环路积分的形式，表示对电荷沿着闭合路径 $l$ 移动时，电场 $\vec{E_k}$ 和 $\vec{E}$ 执行的总功。</li><li>$\epsilon &#x3D; \oint_l (\vec{E_k} + \vec{E}) \cdot d \vec{l}$</li></ul></li></ol><h2 id="16-2-磁场和磁感应强度"><a href="#16-2-磁场和磁感应强度" class="headerlink" title="16-2 磁场和磁感应强度"></a>16-2 磁场和磁感应强度</h2><h3 id="1-磁感应强度"><a href="#1-磁感应强度" class="headerlink" title="1. 磁感应强度"></a>1. 磁感应强度</h3><h4 id="1-1磁感应强度的定义"><a href="#1-1磁感应强度的定义" class="headerlink" title="1.1磁感应强度的定义:"></a>1.1磁感应强度的定义:</h4><p>当正电荷垂直于特定直线运动时，受力$\vec{F_{max}}$ 将$\vec{F_{max}} \times \vec{v}$ 方向定义为该点的$ \vec{B}$ 的方向.</p><p>磁感强度大小: $B&#x3D;\frac{F_{max}}{qv} $</p><p>运动电荷在磁场中受力(洛伦兹力),受力大小为:<br>$ \vec{F} &#x3D; q \vec{v} \times \vec{B}$ </p><img src="E:\DeskTable\博客学习截图传输\image-20231012083921021.png" alt="image-20231012083921021" style="zoom:50%;" /><p>单位:特斯拉 $ 1T &#x3D; 1 N \cdot (A \cdot m)^{-1}$</p><h4 id="1-2-磁感线-有旋无源"><a href="#1-2-磁感线-有旋无源" class="headerlink" title="1.2 磁感线(有旋无源)"></a>1.2 磁感线(有旋无源)</h4><ol><li>理想模型,规定:曲线上每一点的切线方向就是该点的磁感强度<em>B</em>的方向,曲线的疏密程度表示该点的磁感强度<em>B</em>的大小.</li></ol><img src="E:\DeskTable\博客学习截图传输\image-20231012084013228.png" alt="image-20231012084013228" style="zoom:67%;" /><ol start="2"><li>性质:<ul><li>与电流套连 </li><li>闭合曲线 </li><li>方向与电流成右手螺旋关系</li></ul></li></ol><h2 id="16-3-毕奥-萨伐尔定律-磁生电"><a href="#16-3-毕奥-萨伐尔定律-磁生电" class="headerlink" title="16-3 毕奥-萨伐尔定律(磁生电)"></a>16-3 毕奥-萨伐尔定律(磁生电)</h2><p>电流元在空间产生的磁场</p><img src="E:\DeskTable\博客学习截图传输\image-20231012091229844.png" alt="image-20231012091229844" style="zoom:50%;" /><p>$dB &#x3D; \frac{\mu_0}{4 \pi} \frac{I dl \sin{\theta}}{r^2}$$\rightarrow$$d\vec{B} &#x3D; \frac{\mu_0}{4 \pi} \frac{I d\vec{l} \times \vec{r}}{r^3} $</p><p>$\mu_0 为真空电导率,\mu_0 &#x3D; 4 \pi \times 10^{-7} N \cdot A^{-2}$</p><p>任意载流导线在点 <strong>P</strong> 处的磁感强度</p><p>磁感强度叠加:$\vec{B} &#x3D; \int d \vec{B} &#x3D; \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \vec{r}}{r^3} &#x3D; \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \hat{r}}{r^2} $</p><ol><li><p>$\vec{B}$ 表示磁场矢量，它是一个矢量，表示在某个点上的磁场强度和方向。</p></li><li><p>$\int d\vec{B}$ 表示对磁场矢量 $\vec{B}$ 进行积分，通常表示对整个区域的磁场进行积分以获得某一点的总磁场。</p></li><li><p>$\mu_0$ 是真空磁导率</p></li><li><p>$I$ 表示电流，它是电流环中的电流。</p></li><li><p>$d\vec{B}$ 表示磁场小微元，即微小部分的磁场，通常由微小电流元素产生。</p></li><li><p>$\vec{r}$ 是位置矢量，表示观察点到电流元素的距离。</p></li><li><p>$d\vec{l}$ 表示电流元素的微小位移，即在电流环上的微小长度元素。</p></li><li><p>$\times$ 表示矢量叉积，产生一个垂直于 $d\vec{l}$ 和 $\vec{r}$ 的磁场矢量。</p></li><li><p>$r$ 表示观察点到电流微元的距离大小。</p></li><li><p>$\hat{r}$ 是单位矢量，指向&#x3D;&#x3D;观察&#x3D;&#x3D;点到电流元素的方向。</p><p>一个非零向量 $\vec{r}$的<strong>正规化向量</strong> $\hat{r}$ 就是平行于$\vec{r}$的单位向量</p></li></ol><p>$\hat{r} &#x3D; \frac{r}{|| \vec{r} ||}$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的web开发</title>
      <link href="/2023/10/09/cong-ling-kai-shi-de-web-kai-fa/"/>
      <url>/2023/10/09/cong-ling-kai-shi-de-web-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 align=center> 从零开始的web开发 </h1><h1 id="从零开始的web开发"><a href="#从零开始的web开发" class="headerlink" title="从零开始的web开发"></a>从零开始的web开发</h1><p>HTML 定义网页内容</p><p>CSS 描述网页布局</p><p>JavaScript 控制网页行为</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>其实和<strong>markdown</strong>没什么大区别</p><h3 id="定义及特点"><a href="#定义及特点" class="headerlink" title="定义及特点"></a>定义及特点</h3><ul><li>超文本标记语言：Hyper Text Markup Language</li><li>HTML是一种标记语言<ul><li>标记语言即是一套标记标签</li></ul></li><li>使用标记标签来描述网页</li><li>HTML文档包含了HTML标签及文本内容</li><li>HTML文档也称为<strong>web</strong>页面</li></ul><p>一个完整的HTML页面：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span> //声明为HTML5文档//头部元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>//HTML页面的根元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>//包含了文档的元(meta)数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>示例() <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>//可见的页面内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span> 一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span> 一个段落<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的电子电路</title>
      <link href="/2023/09/20/cong-ling-kai-shi-de-dian-gong/"/>
      <url>/2023/09/20/cong-ling-kai-shi-de-dian-gong/</url>
      
        <content type="html"><![CDATA[<h1 align = center> 电工学 </h1><h2 id="2-5-结点电压法"><a href="#2-5-结点电压法" class="headerlink" title="2.5 结点电压法"></a>2.5 结点电压法</h2><h3 id="2-5-0-基本概念："><a href="#2-5-0-基本概念：" class="headerlink" title="2.5.0 基本概念："></a>2.5.0 基本概念：</h3><h2 id="2-7-戴维宁定理和诺顿定理"><a href="#2-7-戴维宁定理和诺顿定理" class="headerlink" title="2.7 戴维宁定理和诺顿定理"></a>2.7 戴维宁定理和诺顿定理</h2><h3 id="2-7-0-基本概念："><a href="#2-7-0-基本概念：" class="headerlink" title="2.7.0 基本概念："></a>2.7.0 基本概念：</h3><h4 id="二端网络："><a href="#二端网络：" class="headerlink" title="二端网络："></a>二端网络：</h4><p>有源——有电源</p><p>无源——无电源</p><img src="E:\DeskTable\博客学习截图传输\image-20230920171844352.png" alt="image-20230920171844352" style="zoom:50%;" /><p><strong>采取的均是等效思想，等效出的电路图对于外部电路效果相同，但是内部并不一定相同</strong></p><h4 id="无源二端网络："><a href="#无源二端网络：" class="headerlink" title="无源二端网络："></a>无源二端网络：</h4><p>因没有电源，只需将各部分支路的电阻通过电阻串并联的规律进行等效变换、化简为一个电阻，再与二端网络之外的电阻放在电路图当中进行讨论即可</p><img src="E:\DeskTable\博客学习截图传输\image-20230920171932963.png" alt="image-20230920171932963" style="zoom:50%;" /><h4 id="有源二端网络："><a href="#有源二端网络：" class="headerlink" title="有源二端网络："></a>有源二端网络：</h4><p>两个定理重点讨论的对象</p><img src="E:\DeskTable\博客学习截图传输\image-20230920172618732.png" alt="image-20230920172618732" style="zoom:50%;" /><p>相对于$R_3$而言，不管$E和R_1和R_2和I_s$有多么复杂，都可以视作一个大电源。则易于进行电路的分析。</p><p>无论是恒压源还是恒流源均可，对于外部电路的分析而言并无太大区别，重要的是将复杂的电路进行简单化。</p><img src="E:\DeskTable\博客学习截图传输\image-20230920172810819.png" alt="image-20230920172810819" style="zoom:50%;" /><img src="E:\DeskTable\博客学习截图传输\image-20230920173220030.png" alt="image-20230920173220030" style="zoom:50%;" /><h3 id="2-7-1-戴维宁定理："><a href="#2-7-1-戴维宁定理：" class="headerlink" title="2.7.1 戴维宁定理："></a>2.7.1 戴维宁定理：</h3><p>任何一个有源二端线性网络都可以用一个电压源来等效代替——电动势为E、内阻为$R_0$ </p><p>求出E和$R_0$的方法</p><img src="E:\DeskTable\博客学习截图传输\image-20230920173739240.png" alt="image-20230920173739240" style="zoom: 67%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>离散课堂活动案例总结</title>
      <link href="/2023/09/18/chi-san-zuo-ye/"/>
      <url>/2023/09/18/chi-san-zuo-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="案例1-命题逻辑与推理规则"><a href="#案例1-命题逻辑与推理规则" class="headerlink" title="案例1(命题逻辑与推理规则)"></a>案例1(命题逻辑与推理规则)</h1><p>当涉及到笔记本电脑的决策和使用时，你同样可以使用命题逻辑和推理规则来帮助做出决策。以下是一个与笔记本电脑相关的案例：</p><p><strong>案例：选择一台笔记本电脑</strong></p><p>你正在考虑购买一台新的笔记本电脑，但市场上有许多不同的品牌和型号可供选择。你可以使用命题逻辑和推理规则来帮助你决定哪台笔记本电脑最适合你的需求。</p><p>命题：</p><ul><li>A: <strong>处理器（CPU）</strong>：处理器是笔记本电脑的大脑，影响计算性能。更高速度和更多核心的处理器通常表示更好的性能。了解处理器的型号和性能评测可以帮助你判断其性能水平。</li><li>B: <strong>内存（RAM）</strong>：内存决定了你能同时运行多少应用程序以及处理大型文件的能力。通常，8GB或更多的RAM对于一般办公和多任务处理足够了，但对于专业图形设计或游戏等任务，16GB或更多可能更合适。</li><li>C: <strong>存储设备</strong>：存储设备包括固态硬盘（SSD）和传统硬盘驱动器（HDD）。SSD比HDD更快，响应更迅速，因此通常更受欢迎。如果你需要更大的存储空间，可以选择具有大容量HDD的笔记本电脑，或者选择具有SSD和HDD组合的双存储笔记本。</li><li>D: <strong>图形处理器（GPU）</strong>：如果你需要进行图形密集型任务，如游戏、视频编辑或3D建模，那么强大的独立GPU可能是必需的。一些轻型笔记本电脑具有集成GPU，适用于日常任务，但不适合高度图形处理的工作。</li><li>E: <strong>屏幕</strong>：屏幕质量包括分辨率、色彩准确性和亮度。高分辨率屏幕通常更适用于多媒体和图形设计任务。IPS面板通常提供更好的色彩和观看角度。</li><li>F: <strong>电池寿命</strong>：电池寿命是移动性能的关键。考虑一台具有长续航时间的笔记本电脑，特别是如果你需要在不插电的情况下工作或旅行。</li><li>G: <strong>连接选项</strong>：确保笔记本电脑具有足够的USB端口、视频输出、无线连接（如Wi-Fi和蓝牙）以及其他必要的连接选项，以满足你的需求。</li><li>H: <strong>散热系统</strong>：有效的散热系统对于长时间使用和高负载任务非常重要，以避免过热导致性能下降。</li><li>I:  <strong>机身质量和设计</strong>：机身质量和设计决定了笔记本电脑的耐用性和外观。选择具有坚固机身和符合你审美喜好的设计的笔记本电脑。</li><li>J: <strong>价格</strong>：最后，考虑你的预算。要确保你的选择在你的预算范围内，同时尽量获得最好的硬件性能和功能。</li></ul><p>推理规则：</p><ul><li>如果一台笔记本电脑的性能高、价格在预算范围内，屏幕尺寸适中，并且品牌有良好的口碑，那么它是值得购买的。这可以表示为：(A ∧ B ∧ C ∧ D) → WorthBuyingLaptop。</li><li>如果一台笔记本电脑的性能高、价格不在预算范围内，那么它可能不是最佳选择。这可以表示为：(A ∧ ¬B) → NotRecommendedLaptop。</li></ul><p>现在，你可以使用这些命题和规则来进行推理，以决定哪台笔记本电脑最适合你。例如，如果你找到一台性能高、价格在预算范围内、屏幕尺寸适中、并且品牌有良好口碑的笔记本电脑，那么根据规则1，你可以得出结论这台笔记本电脑值得购买。</p><p>这个案例展示了如何使用命题逻辑和推理规则来辅助你在选择笔记本电脑时做出明智的决策，考虑了性能、价格、屏幕尺寸和品牌口碑等因素。命题逻辑和推理规则可以帮助你权衡各种因素，以选择最符合你需求的笔记本电脑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的数据结构</title>
      <link href="/2023/09/18/cong-ling-kai-shi-de-shu-ju-jie-gou/"/>
      <url>/2023/09/18/cong-ling-kai-shi-de-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 align=center>从零开始的数据结构</h1><h1 id="一、数据结构的基本三要素："><a href="#一、数据结构的基本三要素：" class="headerlink" title="一、数据结构的基本三要素："></a>一、数据结构的基本三要素：</h1><ol><li><p>逻辑结构</p></li><li><p>存储结构（物理结构）</p></li><li><p>具体的运算，即包含基础操作：数据的访问、添加、删除、更新</p></li></ol><h1 id="二、线性结构"><a href="#二、线性结构" class="headerlink" title="二、线性结构"></a>二、线性结构</h1><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>数组内元素具有相同的类型</li><li>每个元素对应一个唯一的索引，可以通过索引对数组内元素进行操作</li><li>数组大小在创建时固定，因而数组长度和元素个数可知</li><li>在内存中连续存储，可以进行高效的随机访问——通过索引直接访问</li><li></li></ul><h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表(Linked List)"></a>链表(Linked List)</h2><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h2><p>用顺序表进行模拟：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elem<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> usedSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断栈是否满</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> usedSize <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//入栈</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//栈满则扩容</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elem <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elem<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>        usedSize<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断栈是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//出栈</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"栈为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> oldVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span>usedSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"栈为空！"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span>usedSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h2><h2 id="线性-哈希表-Hash"><a href="#线性-哈希表-Hash" class="headerlink" title="(线性)哈希表(Hash)"></a>(线性)哈希表(Hash)</h2><h1 id="三、非线性结构"><a href="#三、非线性结构" class="headerlink" title="三、非线性结构"></a>三、非线性结构</h1><h1 align = center > 树 </h1><h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>树（Tree）是一种常见的数据结构，它具有分层结构，类似于自然界中的树，由节点（Node）和边（Edge）组成。<code>每个树结构都包括一个根节点</code>，该节点没有父节点，而其他节点通过边与根节点和其他节点相连。</p><p>树可以被称为递归数据结构</p><p>树结构有许多不同的应用，包括计算机科学中的数据存储、搜索、排序以及层次性组织等。</p><h3 id="树结构中的常见的术语和特性"><a href="#树结构中的常见的术语和特性" class="headerlink" title="树结构中的常见的术语和特性"></a>树结构中的常见的术语和特性</h3><ol><li><strong>根节点（Root）</strong>：树结构的顶部节点，<strong>没有父节点</strong>，它是树的起始点。</li><li><strong>子节点（Child）</strong>：树中的每个节点可以有<strong>零个或多个</strong>子节点，子节点是其父节点的直接下级节点。</li><li><strong>父节点（Parent）</strong>：每个节点<strong>除了根节点</strong>外，都有一个父节点，它是其子节点的直接上级节点。</li><li><strong>叶子节点（Leaf）</strong>：<strong>没有子节点</strong>的节点称为叶子节点，它们位于树结构的末端 。</li><li><strong>兄弟节点（Sibling）</strong>：<strong>具有相同父节点</strong>的节点称为兄弟节点。</li><li><strong>节点的度</strong>：一个节点包含的子树的个数即为该节点的度</li><li><strong>树的度</strong>：所有节点的度当中的最大值</li><li><strong>节点的层次</strong>：根节点层次为1，以此递增</li><li><strong>深度（Depth）</strong>：从根节点到某个节点的路径上的边数称为该节点的深度。根节点的深度为0。</li><li><strong>高度（Height）</strong>：树结构中任意节点的最长路径（边数）称为树的高度。树的高度通常以根节点为参考。</li><li><strong>子树（Subtree）</strong>：树中的任何节点和其所有后代节点（包括该节点本身）构成的子树。</li><li><strong>有向边（Directed Edge）</strong>：连接两个节点的边<strong>具有方向</strong>，从一个节点指向另一个节点。</li></ol><h3 id="常见的树类型"><a href="#常见的树类型" class="headerlink" title="常见的树类型"></a>常见的树类型</h3><ol><li><p><strong>二叉树（Binary Tree）</strong>：每个节点最多有两个子节点，左子节点和右子节点。</p></li><li><p><strong>二叉搜索树（Binary Search Tree）</strong>：二叉树的一种，具有特定的排序规则，左子树的所有节点值小于根节点的值，右子树的所有节点值大于根节点的值。</p></li><li><p><strong>平衡二叉树（Balanced Binary Tree）</strong>：一种二叉搜索树，具有平衡性质，确保树的高度较低，提高了搜索等操作的效率。</p></li><li><p><strong>B树和B+树</strong>：用于在磁盘上高效存储和检索数据的树状数据结构，常见于数据库管理系统中。</p></li><li><p><strong>树堆（Heap）</strong>：一种特殊的树结构，用于高效查找和删除最大或最小值的元素，通常用于堆排序和优先队列。</p></li><li><p><strong>树结构的图形表示</strong>：树结构通常可以以树状图的方式进行可视化表示，根节点在顶部，子节点向下延伸。</p></li></ol><p>树结构是计算机科学中的重要数据结构之一，它们用于解决各种问题，包括数据存储、搜索、排序、编译器中的语法分析、操作系统中的文件系统等等。了解树结构的基本概念和特性对于编写高效的算法和解决问题非常重要。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>树中的许多操作的时间开销取决于树的高度，因此总希望二叉树的高度尽可能的小</p><h4 id="二叉树的三种遍历："><a href="#二叉树的三种遍历：" class="headerlink" title="二叉树的三种遍历："></a>二叉树的三种遍历：</h4><ul><li>前序遍历——先后访问根节点、左子树、右子树</li><li>中序遍历——先后访问左子树、根节点、右子树</li><li>后序遍历——先后访问左子树、右子树、根节点</li></ul><p>三序的遍历有更加直观易记的方法 <a href="https://www.bilibili.com/video/BV1Ub4y147Zv/?spm_id_from=333.337.search-card.all.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">无脑画点连线法，一学就会</a> 作者：<a href="https://space.bilibili.com/446171901">阿琛w</a></p><p>具体思路：</p><p>对于任意一颗树而言，前序遍历的形式总是<br>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是<br>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p><p>已知其中xx和xx序，推测第三种yy序：</p><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。</p><p>由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>细节</p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希映射（HashMap）来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p><p>————————————————<br>版权声明：本文为CSDN博主「看，未来」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43762191/article/details/107280503">种树：二叉树、二叉搜索树、AVL树、红黑树、哈夫曼树、B树、树与森林</a></p><p>————————————————</p><p>作者：LeetCode-Solution<br>原文链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">从前序与中序遍历序列构造二叉树</a></p><h3 id="完整二叉树（Complete-Binary-Tree）"><a href="#完整二叉树（Complete-Binary-Tree）" class="headerlink" title="完整二叉树（Complete Binary Tree）"></a>完整二叉树（Complete Binary Tree）</h3><p>完整二叉树（Complete Binary Tree）是一种二叉树，其中每一层都被完全填充，<strong>除了最后一层</strong>可能不是满的，但是最后一层的所有节点都<strong>集中在该层的左侧</strong>。</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ol><li>所有叶子节点都出现在最后一层或倒数第二层。</li><li>如果有子节点，每个节点都有两个子节点。</li><li>最后一层的节点都尽可能地靠左排列。</li></ol><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><pre class=" language-html"><code class="language-html">      1    /   \   2     3  / \   / 4   5 6</code></pre><h3 id="完美二叉树（Perfect-Binary-Tree）"><a href="#完美二叉树（Perfect-Binary-Tree）" class="headerlink" title="完美二叉树（Perfect Binary Tree）"></a>完美二叉树（Perfect Binary Tree）</h3><p>完美二叉树（Perfect Binary Tree），也被称为满二叉树（Full Binary Tree），是一种特殊类型的二叉树</p><h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ol><li>每个非叶子节点都有两个子节点。</li><li>所有叶子节点都在同一层级上，也就是说，树的<strong>所有层级都被完全填充</strong>。</li></ol><p>这意味着在完美二叉树中，每一层都包含最大数量的节点，即每一层的节点数都是2的幂次方。完美二叉树的高度（深度）通常由叶子节点的层级决定，如果有h层，则叶子节点位于第h层，树的高度为h。</p><h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><pre><code>        1      /   \     2     3    / \   / \   4   5 6   7</code></pre><h3 id="二叉搜索树（Binary-Search-Tree，BST）"><a href="#二叉搜索树（Binary-Search-Tree，BST）" class="headerlink" title="二叉搜索树（Binary Search Tree，BST）"></a>二叉搜索树（Binary Search Tree，BST）</h3><p>二叉搜索树（Binary Search Tree，BST）是一种二叉树的特殊形式。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>每个节点都包含一个值（通常是一个可比较的值），并且这些值按照特定的顺序排列。</li><li>对于每个节点：<ul><li>所有左子树中的节点的值都小于该节点的值。</li><li>所有右子树中的节点的值都大于该节点的值。</li><li>左右子树都是二叉搜索树。</li><li>每个节点的左右子树也是BST</li></ul></li><li>左子树的每一个节点的键值一定小于右子树每一个节点的键值（即右子树最小的键值）</li></ol><p>这个特性使得二叉搜索树非常适合进行快速的搜索、插入和删除操作，因为它充分利用了值的相对大小来构建树结构。如果树的结构是平衡的，搜索、插入和删除操作的时间复杂度通常为O(log n)，其中n是树中节点的数量。</p><h4 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h4><pre><code>        5       / \      3   8     / \ / \    1  4 7  9</code></pre><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>需要注意的是，如果二叉搜索树的<strong>结构不平衡</strong>，即左子树和右子树的高度差异很大，搜索操作的性能可能会退化到O(n)，其中n是树中节点的数量。在极限情况下可能退化成链表（重新变成线性结构）</p><h4 id="BST常见操作："><a href="#BST常见操作：" class="headerlink" title="BST常见操作："></a>BST常见操作：</h4><h5 id="1、查找（搜索）："><a href="#1、查找（搜索）：" class="headerlink" title="1、查找（搜索）："></a>1、查找（搜索）：</h5><p>采取递归式搜索：</p><ol><li>value &lt; root，则向根节点左侧向下搜索</li><li>value &gt; root，则向根节点右侧向下搜索</li><li>当root为空或&#x3D;&#x3D;value时，直接返回为空或者返回根节点的值</li></ol><h5 id="2、插入："><a href="#2、插入：" class="headerlink" title="2、插入："></a>2、插入：</h5><p>新元素进入后，遇到大于的键值val的向左走，小于键值val的向右走，一直到尾端</p><h5 id="3、删除："><a href="#3、删除：" class="headerlink" title="3、删除："></a>3、删除：</h5><p>假设删除A节点</p><ol><li>A的度为0（叶节点）：直接移除A</li><li>A的度为1：A节点的节点直接补上</li><li>A的度为2：将A节点右子树键值最小的节点补上</li></ol><h3 id="线索二叉搜索树（）"><a href="#线索二叉搜索树（）" class="headerlink" title="线索二叉搜索树（）"></a>线索二叉搜索树（）</h3><p>在原来二叉树的基础上引入前驱和后继的概念，使得原来以树状逻辑排放的元素重新以线性逻辑排放。</p><p>存在一定问题，即某些节点的右节点即是其后继，或者其左节点即是其前驱</p><h3 id="平衡二叉树（Balanced-Binary-Tree）"><a href="#平衡二叉树（Balanced-Binary-Tree）" class="headerlink" title="平衡二叉树（Balanced Binary Tree）"></a>平衡二叉树（Balanced Binary Tree）</h3><p>平衡二叉树（Balanced Binary Tree），也称为平衡二叉搜索树（Balanced Binary Search Tree），是一种特殊类型的二叉搜索树（BST），因二叉搜索树的查找效率取决于树的高度，因而进一步提出而平衡二叉搜索树来保持树的高度达到最小。</p><h4 id="E-p："><a href="#E-p：" class="headerlink" title="E.p："></a>E.p：</h4><p>当输入序列 {1，2，3，4，5，6}，仍使用普通的二叉搜索树会退化成单链表：</p><p><img src="https://img-blog.csdnimg.cn/20200711144946466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img"></p><p>但使用平衡二叉搜索树则是：当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。这种左右子树的高度相差不超过1的树为平衡二叉树。</p><p><img src="https://img-blog.csdnimg.cn/20200711145115978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>每个节点都包含一个值（通常是可比较的值）。</li><li>对于每个节点：<ul><li>左子树和右子树的高度之差（平衡因子）最多为1。</li><li>左右子树都是平衡二叉树。</li></ul></li></ol><p>平衡二叉树的关键特性是它的高度相对较低，因此搜索、插入和删除操作的时间复杂度通常是O(log n)，其中n是树中节点的数量。</p><h4 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h4><pre><code>        4       / \      2   6     / \ / \    1  3 5  7</code></pre><h3 id="AVL树的构造："><a href="#AVL树的构造：" class="headerlink" title="AVL树的构造："></a>AVL树的构造：</h3><p>由上图可知：插入62节点之后，先进行普通的BST的插入，此时左子树高度为1，右子树高度为3，平衡因子的绝对值 &#x3D;&#x3D; 2，树失衡则需进行旋转操作：</p><h4 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h4><h4 id="左旋（LL平衡旋转）操作的步骤："><a href="#左旋（LL平衡旋转）操作的步骤：" class="headerlink" title="左旋（LL平衡旋转）操作的步骤："></a>左旋（LL平衡旋转）操作的步骤：</h4><ol><li>设定一个不平衡的节点为X，其右子树的高度比左子树高度高。</li><li>将X的右子节点Y取出，并将Y的左子节点B连接到X的右子节点。</li><li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点，以保持树的连接。</li><li>最后，将X连接到Y的左子节点B上。</li></ol><p>左旋操作后，X会变成Y的左子节点，而Y会成为X的父节点，从而保持了树的平衡性。</p><p>一直遍历，直到找到平衡因子的绝对值不为1的节点进行旋转操作。</p><p><strong>40</strong>的右节点<strong>51</strong>的左节点<strong>46</strong>接到<strong>40</strong>的右节点，而后将<strong>40</strong>这一节点接到<strong>51</strong>的左节点，如下图所示：</p><img src="https://img-blog.csdnimg.cn/2020071115165424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /><img src="https://img-blog.csdnimg.cn/20200711151718338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img" style="zoom:86%;" /><h4 id="右旋（RR平衡旋转）操作的步骤如下："><a href="#右旋（RR平衡旋转）操作的步骤如下：" class="headerlink" title="右旋（RR平衡旋转）操作的步骤如下："></a>右旋（RR平衡旋转）操作的步骤如下：</h4><ol><li>设定一个不平衡的节点为X，其左子树的高度比右子树高度高。</li><li>将X的左子节点Y取出，并将Y的右子节点B连接到X的左子节点。</li><li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点。</li><li>最后，将X连接到Y的右子节点B上。</li></ol><p>右旋操作后，X会变成Y的右子节点，而Y会成为X的父节点，也能够保持树的平衡性。</p><p>A处的节点左右失衡，找到失衡节点的左节点B，将B的右节点E和B断开，接入A的左节点，而后将A接入到B的右节点。</p><p><img src="https://img-blog.csdnimg.cn/20200711154951407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200711155008636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="双旋转（不平衡节点在内侧）"><a href="#双旋转（不平衡节点在内侧）" class="headerlink" title="双旋转（不平衡节点在内侧）"></a>双旋转（不平衡节点在内侧）</h4><h4 id="先左后右双旋转（LR平衡旋转）"><a href="#先左后右双旋转（LR平衡旋转）" class="headerlink" title="先左后右双旋转（LR平衡旋转）"></a>先左后右双旋转（LR平衡旋转）</h4><p>左孩子右子树上插入新的节点，导致的不平衡</p><p><img src="C:\Users\moru\AppData\Roaming\Typora\typora-user-images\image-20230918112359944.png" alt="image-20230918112359944"></p><h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><p><a href="https://zhuanlan.zhihu.com/p/348797577">深入理解伸展树(splay tree) - 知乎 (zhihu.com)</a></p><p>本质也是一颗二叉搜索树，但引入假设——当一个节点被访问时，该节点下一次被访问的可能性很大。基于该假设做出操作：每次一个节点被访问时，将该节点推到根节点的位置。</p><p>统计意义上的平衡树</p><p>这种结构可以不考虑进行树的平衡调整。</p><h4 id="单R-L型"><a href="#单R-L型" class="headerlink" title="单R&#x2F;L型"></a>单R&#x2F;L型</h4><p>根节点是查找节点的父节点。相当于直接将该节点提起，其他节点相对位置保持不变</p><img src="https://img-blog.csdn.net/20151102155743401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom: 67%;" /><img src="https://img-blog.csdn.net/20151102155639325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:73%;" /><h4 id="RR-LL型："><a href="#RR-LL型：" class="headerlink" title="RR&#x2F;LL型："></a>RR&#x2F;LL型：</h4><h4 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h4><p>单旋转</p><p>之字型</p><p>一字型</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（Binary Search Tree）。它是由Rudolf Bayer于1972年首次提出，后来由Leo J. Guibas和Robert Sedgewick进行改进。红黑树之所以重要，是因为它保持了二叉搜索树的基本性质，并在其上加入了一些额外的规则来确保树的高度保持在较小的范围内，从而保证了搜索、插入和删除操作的高效性。</p><h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h4><ol><li>每个节点都有一个颜色，可以是红色或黑色。</li><li>根节点是黑色的。</li><li>所有叶子节点（NIL节点）都是黑色的。</li><li>叶节点是不存储数据的黑色空节点</li><li>如果一个节点是红色的，则其两个子节点必须是黑色的（不能有两个相连的红色节点）。</li><li>从任意节点到其每个叶子节点的路径都包含相同数量的黑色节点，这被称为黑色高度。</li></ol><p>这些性质确保了红黑树在插入和删除操作后能够自动调整自身，以保持平衡，从而避免出现最坏情况的性能。</p><p>红黑树广泛用于各种编程语言和数据结构中，包括C++的STL中的<code>std::map</code>和<code>std::set</code>，以及Java的<code>java.util.TreeMap</code>和<code>java.util.TreeSet</code>等。它们支持高效的搜索、插入和删除操作，并且在保持数据有序的同时，具有可预测的性能。</p><p>红黑树的操作复杂度为O(log n)，其中n是树中节点的数量。这使得它成为许多算法和数据结构的重要组成部分，特别是需要高效插入和删除操作的情况下。</p><h3 id="B-树（多-M路搜索树）"><a href="#B-树（多-M路搜索树）" class="headerlink" title="B-树（多&#x2F;M路搜索树）"></a>B-树（多&#x2F;M路搜索树）</h3><p><img src="E:\DeskTable\博客学习截图传输\image-20230922101648057.png" alt="image-20230922101648057"></p><p>（课本把终端节点当作叶子节点，所以“数据放在叶子节点”）</p><h4 id="B树提出的主要目的："><a href="#B树提出的主要目的：" class="headerlink" title="B树提出的主要目的："></a>B树提出的主要目的：</h4><p>减少磁盘I&#x2F;O操作。</p><p><strong>一颗m阶B树即是一颗平衡的m路搜索树</strong></p><p><strong>一颗B树的阶由叶子节点最多的分叉决定</strong></p><h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>B树可以视为将原本的二叉搜索树引入区间的概念，即将要每一个子节点根据键值进行区间的划分，从而通过比较待搜索的数和区间的关系进行查找。</p><ul><li><p>绝对平衡，因所有子树都在同一层</p></li><li><p>数据项存储在叶子节点上（即之前所有的节点均为索引或者说关键字&#x2F;键）</p></li><li><p>叶子节点的下一层（均为空节点）均为失败节点，出现在同一层，代表搜索失败的节点</p></li><li><p>非叶子节点存储直到</p></li><li><p>非根节点点至少有：$[m&#x2F;2]$(向上取整) 个子树，至多有$m$个子树</p></li><li><p>非根节点的关键字：</p><ul><li>有序（升序或者降序</li><li>最少有：$[M&#x2F;2]-1$(向上取整)；最多有：$M-1$(子节点数-1)</li></ul></li><li><p>根节点最少 1个关键字（二叉），最多M-1个关键字（M叉），即根节点儿子个数取值范围$[2,m]$</p></li></ul><h4 id="基础操作："><a href="#基础操作：" class="headerlink" title="基础操作："></a>基础操作：</h4><h4 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h4><p>与<strong>BST</strong>类似，由根节点出发，递归向下查找。</p><h3 id="B-树（M阶）："><a href="#B-树（M阶）：" class="headerlink" title="B+树（M阶）："></a>B+树（M阶）：</h3><p>基于B树提出，不同之处：</p><ol><li><p>非叶子节点子树指针个数与关键字个数相同</p></li><li><p>非叶子节点的子树指针P[i]-&gt;[K[i],K[i+1]]</p></li><li><p>所有叶子节点增加一个链指针，所有关键字都在叶子节点出现</p></li><li><p>B+树内部有两种节点，一种索引节点，一种叶子节点。</p></li><li><p>B+树索引——只用于索引，所有的数据保存</p></li></ol><h1 align = center> 哈希表 </h1><h2 id="非线性-哈希表"><a href="#非线性-哈希表" class="headerlink" title="(非线性)哈希表"></a>(非线性)哈希表</h2><p>哈希表，也叫散列表，一种由关键字到值并使用数组存储的数据结构</p><p>有一个hash function，关键字——hash function —— 值，将每个关键字映射到一个表当中。</p><p>理想当中，每一个关键字在经过hash function 后会有各自的值，但实际操作中，很可能不同的关键字得出相同的值，则会造成 <strong>hash冲突</strong>，因而会有以下几种解决冲突的方法。</p><p>1、分离链表法（separate chaining）：</p><p>将具有相同<strong>值</strong>的关键字存储到同一个 值链表 当中</p><p>2、开放地址法（Closed Hash Tbales&#x2F;Open Adderssing）</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>1、二叉堆，简称堆：</p><p>堆是一颗完全填满的二叉树(叶子节点可以不填满，但是需要从左到右填充)，即一颗完全二叉树</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231008101022069.png" alt="image-20231008101022069"></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的计组</title>
      <link href="/2023/09/15/cong-ling-kai-shi-de-ji-suan-ji-zu-cheng-yuan-li/"/>
      <url>/2023/09/15/cong-ling-kai-shi-de-ji-suan-ji-zu-cheng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 align =center > 计算机组成原理 </h1><h1 id="Chapter9-Arithmetic"><a href="#Chapter9-Arithmetic" class="headerlink" title="Chapter9 Arithmetic"></a>Chapter9 Arithmetic</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li><p>数据本身毫无意义，但可以用来在统一观念下进行特定的解释，创造出抽象的概念，赋予其特定场景下的含义。</p></li><li><p>硬件实现的数据类型——数据表示</p></li><li><p>软件实现的数据类型——数据结构</p></li></ul><h2 id="数的表示："><a href="#数的表示：" class="headerlink" title="数的表示："></a>数的表示：</h2><h3 id="1、整数"><a href="#1、整数" class="headerlink" title="1、整数"></a>1、整数</h3><ul><li><p>原码</p></li><li><p>反码</p></li><li><p>补码</p></li></ul><p>首位为“0”——正数；首位为“1”——负数</p><p>正数的三种码都一样，负数才有区别</p><h2 id="BCD码（Binary-Coded-Decimal）"><a href="#BCD码（Binary-Coded-Decimal）" class="headerlink" title="BCD码（Binary-Coded Decimal）"></a>BCD码（Binary-Coded Decimal）</h2><h3 id="8421码（有权码）最常见："><a href="#8421码（有权码）最常见：" class="headerlink" title="8421码（有权码）最常见："></a>8421码（有权码）最常见：</h3><p>采取 4个二进制位对应一个十进制位</p><p>每一位的权重分别为：8、4、2、1</p><p>计算方法：</p><p>E.p ：5（0101）+ 8（1000） &#x3D; 13（1101）不在映射内（1010~1 0010）则加上6进行修正</p><p>则13（1101）+ 6（0110） &#x3D; 19（1 0011）&#x3D;&#x3D; 1（00001）&amp;&amp; 3（0011）</p><h3 id="2421码："><a href="#2421码：" class="headerlink" title="2421码："></a>2421码：</h3><p>重定义的权值</p><img src="E:\DeskTable\博客学习截图传输\image-20230919163128770.png" alt="image-20230919163128770" style="zoom:50%;" /><h3 id="其他的4位有权BCD码："><a href="#其他的4位有权BCD码：" class="headerlink" title="其他的4位有权BCD码："></a>其他的4位有权BCD码：</h3><p>5421码、5211码、4311码 —— 这三种对9互补，逢十进一</p><p>84-2-1（八四负二负一）码</p><h3 id="余3码（无权码）："><a href="#余3码（无权码）：" class="headerlink" title="余3码（无权码）："></a>余3码（无权码）：</h3><p>$8421码 + (0011)_2$</p><h3 id="其他的4位无权BCD码："><a href="#其他的4位无权BCD码：" class="headerlink" title="其他的4位无权BCD码："></a>其他的4位无权BCD码：</h3><p>格雷码（1）、格雷码（2）、格雷码（3）</p><h2 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h2><p><strong>原码</strong>：</p><p>特点：</p><ul><li>含有+0和-0</li><li>计算乘除法比较方便，加减法较麻烦</li></ul><p>为了简便加减法运算，设计出了<strong>补码</strong></p><p><strong>补码</strong>：</p><ul><li>无模运算：实数范围内进行运算</li><li>有模运算：<ol><li>概念：给定一个正整数p，任意一个整数n，一定存在等式 n &#x3D; k*p + r<br>其中k 、r 是整数，且 0 ≤ r &lt; p 称呼k 为n 除以p 的商，r 为n 除以p的余数。</li><li>有模运算体系当中，减去一个数等于加上这个数对模的补数。如a+b&#x3D;M a和b互为补数</li></ol></li><li>（二进制）正数的补码是其本身，负数（无论整数还是小数 ）的补码，将负数变成补码——每一位取反末位加一</li></ul><p>在计算机当中，加减法均采用补码进行</p><ul><li><p>在纯小数二进制编码当中 补码为1.0000000 —&gt;真值：-1.0000000 最高位表示为数值位也是符号位；原码：超出范围</p></li><li><p>补码符号位拓展：</p></li></ul><p>  将n位定点整数补码拓展到2n位：</p><ul><li>当补码表示正数时，则直接在前面补上n个0即可</li><li>当补码表示负数时，则在前面补上n个1即可</li></ul><p>  即与符号位保持一致进行拓展</p><ul><li>算术右移（除2运算）</li></ul><p>一个数算术右移1位后，其最低有效位被移出。低位舍去，高位补符号位</p><p>小数 正数情况：低位舍去，高位补0</p><p>​负数情况：低位舍去，高位补1</p><ul><li>算术左移（乘2运算）</li></ul><p><strong>移码</strong>：</p><p>移码的值和真值成线性正比关系</p><p>无论正负数：补码求移码——符号位取反即可</p><p><strong>三种码的相互转换</strong>：</p><p>1、机器数是正数——符号位为0</p><p>原码&#x3D;反码&#x3D;补码</p><p>2、机器数是负数——符号位为1</p><p>反码&#x3D;原码（符号位除外）取反</p><p>补码&#x3D;反码末尾+1</p><p>无论正负数，移码&#x3D;补码符号位直接取反</p><p><a href="https://www.bilibili.com/video/BV1KP411X71M/?p=2&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.02.29 补码的性质2；反码、移码_哔哩哔哩 bilibili</a> 学习到了 0:28:04</p><p><strong>总结</strong>：</p><p>正数的原码，补码，反码<strong>相同</strong>；</p><p>负数的反码：原码的数值（符号位除外）取反；</p><p>负数的补码：原码转换成反码，反码末位加1</p><p>负数的移码：与补码的符号位取反</p><p>已知补码求原码：</p><p>最高位如果是1的话（负数），那么除了最高位之外的取反，然后加1得原码。</p><p>最高位如果是0的话，不变，正数的补码就是他的原码。<br>————————————————<br>版权声明：本文为CSDN博主「隔壁郑同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_44517301/article/details/93890346">https://blog.csdn.net/weixin_44517301/article/details/93890346</a></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><a href="https://www.bilibili.com/video/BV1KP411X71M?p=3&vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.03.04 浮点数的一般格式1</a></p><p>科学计数法：</p><ul><li>动态移动十进制小数点到约定位置，并使用10的指数来记录此小数点的位置</li><li>可表示整数也可表示小数</li><li>可表示范围很大</li><li>规格化数字</li></ul><img src="E:\DeskTable\博客学习截图传输\image-20230919092538911.png" alt="image-20230919092538911" style="zoom:50%;" /><p>数符：表示浮点数的符号</p><p>阶符：</p><p>阶码：（数值部分）从高位开始进行比较 阶码位数表示表示范围</p><p>尾数：（数值部分） 尾数位数越多，精度越高</p><p>所谓的浮点数表示其实可以简单粗暴的理解成，把一个数按照以2为模的科学计数法，将符号（+ -）放在首位——数符，将2^n以二进制形式放在前面——阶码，把数的部分以二进制码形式放在后面——尾数</p><p>但是二进制的尾数是纯小数形式，不需要小数点前有有效数字。</p><p>规格化的浮点数：</p><p>在计算机当中尾数的表示一般采取的是原码，但是补码也得了解了解</p><ul><li><p>如果阶码的底为2，则尾数应该满足 1&#x2F;2 &lt;&#x3D; |M| &lt; 1 —— 原码 小数点右侧第一位为1（0.1xxxxxxx……） </p></li><li><p>当尾数用补码表示：</p><ul><li><p>尾数M&gt;&#x3D;0时，尾数应当具有的格式：M &#x3D; 0.1xxxxx…x，$当M \geq 0 时，[\frac{1}{2}]_补 \leq [M]_补 &lt; [1]_补$</p></li><li><p>尾数M&lt;0时，不将$[-1&#x2F;2]_补$列入规格化的数，而把$[1]_补$列入规格化的数当中。</p></li><li><p>即: $[1&#x2F;2]_补 \geq [M]_补 \leq [1]_补 $</p></li></ul></li><li><p>左规：</p><p>采用变形补码表示尾数，则当结果的尾数出现11.11xxxx或00.0xxxx时，将尾数左移1位，阶码-1，直到尾数变为<strong>规格化</strong>形式为止</p></li><li><p>右规：  </p><p>当结果尾数出现01.xxxx……x或者10.xxx……x时，并不一定溢出，应当先把尾数右移一位，阶码+1，在判断阶码是否溢出</p></li></ul><h2 id="奇偶校验码："><a href="#奇偶校验码：" class="headerlink" title="奇偶校验码："></a>奇偶校验码：</h2><p>对于一个n位的信息，在最前面增加一个奇偶校验位，即通过这个增加的校验位来使得整个有效信息串当中的1的个数达到“奇数”——对应奇校验 或者“偶数”——对应偶校验</p><h3 id="方法局限性："><a href="#方法局限性：" class="headerlink" title="方法局限性："></a>方法局限性：</h3><p>当出现偶数个位数的错误时，则无法进行校验。</p><h3 id="奇校验："><a href="#奇校验：" class="headerlink" title="奇校验："></a>奇校验：</h3><p>整个校验码（有效信息位和校验位）当中“1”的个数位奇数</p><h3 id="偶校验："><a href="#偶校验：" class="headerlink" title="偶校验："></a>偶校验：</h3><p>整个校验码（有效信息位和校验位）当中“1”的个数位偶数</p><h3 id="校验："><a href="#校验：" class="headerlink" title="校验："></a>校验：</h3><p>使用<strong>异或运算</strong>操作进行偶校验，结果为0则未出错，结果为1则出错</p><h2 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h2><h2 id="（Arithmetic-and-Logic-Unit，ALU）"><a href="#（Arithmetic-and-Logic-Unit，ALU）" class="headerlink" title="（Arithmetic and Logic Unit，ALU）"></a>（Arithmetic and Logic Unit，ALU）</h2><img src="E:\DeskTable\博客学习截图传输\image-20230919213319875.png" alt="image-20230919213319875" style="zoom: 67%;" /><h2 id="IEEE745标准："><a href="#IEEE745标准：" class="headerlink" title="IEEE745标准："></a>IEEE745标准：</h2><p>尾数的格式：</p><p>规格化的原码表示—— S.1xxxxxx</p><p>规格化补码表示—— 正数：0.1xxxxxx负数：1.0xxxxxx</p><h2 id="二进制的乘法："><a href="#二进制的乘法：" class="headerlink" title="二进制的乘法："></a>二进制的乘法：</h2><p>Booth法和阵列乘法器以及除法</p><h3 id="补码的乘法运算规则："><a href="#补码的乘法运算规则：" class="headerlink" title="补码的乘法运算规则："></a>补码的乘法运算规则：</h3><img src="E:\DeskTable\博客学习截图传输\image-20230921184009102.png" alt="image-20230921184009102" style="zoom:50%;" /><p>补码的编码值按位展开得到真值，正数符号位权值为<strong>1</strong>，负数符号位权值为**-1**</p><h3 id="原码一位乘法："><a href="#原码一位乘法：" class="headerlink" title="原码一位乘法："></a>原码一位乘法：</h3><p>和手算一样</p><img src="E:\DeskTable\博客学习截图传输\image-20230923105803490.png" alt="image-20230923105803490" style="zoom:27%;" /><p>加法次数和相乘的两个原码的位数相同</p><h3 id="Booth法"><a href="#Booth法" class="headerlink" title="Booth法"></a>Booth法</h3><h4 id="时序逻辑电路图"><a href="#时序逻辑电路图" class="headerlink" title="时序逻辑电路图"></a>时序逻辑电路图</h4><p>无符号：Booth法的电路是时序逻辑电路，具有时钟信号控制</p><img src="E:\DeskTable\博客学习截图传输\image-20230922162220296.png" alt="image-20230922162220296" style="zoom:50%;" /><h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><h4 id="1）手算及单元电路"><a href="#1）手算及单元电路" class="headerlink" title="1）手算及单元电路"></a>1）手算及单元电路</h4><img src="E:\DeskTable\博客学习截图传输\image-20230923101554580.png" alt="image-20230923101554580" style="zoom: 30%;" /><h4 id="2）、定点无符号数阵列乘法器"><a href="#2）、定点无符号数阵列乘法器" class="headerlink" title="2）、定点无符号数阵列乘法器"></a>2）、定点无符号数阵列乘法器</h4><p>组合逻辑电路因为不需要根据时钟周期进行移位累加，所使用的时间会少于移位累加的方法</p><p><img src="E:\DeskTable\博客学习截图传输\image-20230922170428659.png" alt="image-20230922170428659"></p><img src="E:\DeskTable\博客学习截图传输\image-20230923101344400.png" alt="image-20230923101344400" style="zoom:30%;" /><h4 id="3）、有符号数的阵列乘法"><a href="#3）、有符号数的阵列乘法" class="headerlink" title="3）、有符号数的阵列乘法"></a>3）、有符号数的阵列乘法</h4><p>下图中的电路可以完美实现一个二进制数的求补操作，即——从右往左找到第一个<strong>1</strong>，之后的所有位按位取反</p><p>可通过图中电路图可以做到</p><ol><li>已知一个数的补码，求该数的绝对值</li><li>已知一个数的绝对值，求该数的补码</li></ol><img src="E:\DeskTable\博客学习截图传输\image-20230923102304075.png" alt="image-20230923102304075" style="zoom:25%;" /><img src="E:\DeskTable\博客学习截图传输\image-20230923102750917.png" alt="image-20230923102750917" style="zoom:26.5%;" /><h2 id="二进制的除法"><a href="#二进制的除法" class="headerlink" title="二进制的除法"></a>二进制的除法</h2><h3 id="1）、原码除法"><a href="#1）、原码除法" class="headerlink" title="1）、原码除法"></a>1）、原码除法</h3><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ol><li>前提条件<ol><li>除数 !&#x3D; 0 </li><li>定点纯小数时，被除数绝对值小于除数，商的结果位数与除数保持一致，则认为精度足够了 </li><li>定点纯整数时，被除数绝对值大于或等于除数</li></ol></li><li>商的符号&#x3D;&#x3D;被除数符号<strong>异或</strong>除数符号</li><li>商的绝对值&#x3D;&#x3D;被除数绝对值&#x2F;除数绝对值</li><li>将符号和绝对值拼接</li></ol><p>由手算引入逻辑实现</p><img src="E:\DeskTable\博客学习截图传输\image-20230923103943081.png" alt="image-20230923103943081" style="zoom:30%;" /><h3 id="2）、恢复余数法"><a href="#2）、恢复余数法" class="headerlink" title="2）、恢复余数法"></a>2）、恢复余数法</h3><img src="E:\DeskTable\博客学习截图传输\image-20230923105332402.png" alt="image-20230923105332402" style="zoom:29.5%;" /><p><img src="/%5Cimage/image.p" alt="Alt text"></p><h1 align=center> 存储体系结构 </h1><h1 id="Ch8-计算机存储体系结构"><a href="#Ch8-计算机存储体系结构" class="headerlink" title="Ch8 计算机存储体系结构"></a>Ch8 计算机存储体系结构</h1><h2 id="8-1-Basic-Concepts"><a href="#8-1-Basic-Concepts" class="headerlink" title="8.1 Basic Concepts"></a>8.1 Basic Concepts</h2><img src="E:\DeskTable\博客学习截图传输\image-20231010221402861.png" alt="image-20231010221402861" style="zoom: 33%;" /><img src="E:\DeskTable\博客学习截图传输\image-20231010222309462.png" alt="image-20231010222309462" style="zoom: 50%;" /><img src="E:\DeskTable\博客学习截图传输\image-20231010222624421.png" alt="image-20231010222624421" style="zoom:50%;" /><h3 id="存储器的不同特性"><a href="#存储器的不同特性" class="headerlink" title="存储器的不同特性"></a>存储器的不同特性</h3><ul><li>存储信息的介质，物质类型<ul><li>Semiconductor，半导体</li><li>Magnetic Surface，磁盘，磁带</li><li>Optical，光盘</li></ul></li><li>用途</li><li>信息的易失性&#x2F;非易失性</li><li>转移单位</li><li>存取方式<ul><li>随机——存取时间和物理地址无光，任一单元的读写所需时间相同</li><li>顺序</li></ul></li><li>读写功能</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul><li><p>内存(Primary Storage)：计算机中直接被处理器(Processor)访问的存储器，也称为主存（Main Memory）或内部存储器（Internal Memory）。</p><ul><li>内存可以存储当前运行的程序和数据，以供处理器使用。</li></ul></li><li><p>内存比起外部存储器：读写速度更快，容量小，价格高</p></li><li><p>内存的类型有很多，常见的有随机存取存储器（RAM）、只读存储器（ROM）、高速缓冲存储器（Cache）。</p><ul><li><p>随机存取存储器（Random Access Memory,RAM）是一种可读写的内存，也叫做主存。它可以随机地访问任何一个地址的数据，而不需要按照顺序。RAM是易失性的，也就是说，当断电时，它会丢失所有的数据。</p><ul><li>RAM有两种主要的子类：<ul><li>静态RAM（Staic Random Access Memory,SRAM）：不掉电，则内容不丢失</li><li>动态RAM（Dynamic Ranodm Access Memory,DRAM）<ul><li>同步DRAM（Synchronous DRAM,SDRAM）</li></ul></li></ul></li></ul></li><li><p>只读存储器（Read Only Memory,ROM）是一种只能读取的内存，也叫做固件。它通常用来保存一些不会改变的数据或程序，例如计算机启动时的基本输入输出系统（BIOS）。ROM是非易失性的，也就是说，当断电时，它不会丢失数据。</p><ul><li>ROM有三种主要的子类：<ul><li>可编程只读存储器（PROM）</li><li>可擦除可编程只读存储器（EPROM）</li><li>电子可擦除可编程只读存储器（EEPROM）</li><li>闪速（Flash） ：<ul><li>NOR</li><li>NAND</li></ul></li></ul></li><li>ROM当中存储有一段代码指令<strong>BIOS</strong>，作用：<ul><li>硬件自检</li><li>输入输出接口初始化</li><li>最后跳转到MM当中的引导扇区，以及操作系统的启动</li></ul></li></ul></li><li><p>高速缓冲存储器（Cache）是一种位于处理器和主存之间的高速内存，它可以缓存一些经常使用的数据或指令，以减少处理器访问主存的时间。</p><p>Cache是静态RAM（SRAM）制造的，它比动态RAM（DRAM）更快，但也更贵。</p><ul><li>Cache有多个级别，通常分为一级缓存（L1）、二级缓存（L2）和三级缓存（L3）。</li></ul></li></ul></li><li><p>主存的运作（作用）：</p><ul><li><p>Connection of the Memory to the Processor——连接存储器和处理器</p></li><li><p>Processor-Memory Interface</p><ul><li>[处理器-内存接口的主要目的是让处理器能够读取或写入内存中的数据，以执行指令或存储结果。](<a href="http://www.ee.ic.ac.uk/pcheung/teaching/ee2_digital/Lecture">http://www.ee.ic.ac.uk/pcheung/teaching/ee2_digital/Lecture</a> 13 - memory interface.pdf)</li><li>基本原理：当处理器需要访问内存时，它会将内存地址发送到地址总线上，然后通过一个解码电路来选择相应的内存芯片或设备。</li></ul></li><li><p>Read(Load) Operation</p><ul><li>将一个特定内存位置的数据副本读到处理器（Processor）</li><li>Processor： Load the address of the required memory location  into the MAR register and set the R&#x2F;W line to 1</li><li>Memory：Place the data from the addressed location onto the  data lines and confirm this action by asserting the MFC signal</li><li>Processor: Upon receipt of the MFC signal, the processor loads  the data on the data lines into the MDR register.</li></ul></li><li><p>Write(Store) Operation</p><ul><li>将一项信息从处理器传输到特定位置，销毁该位置先前的内容。</li><li>Processor： Load the address of the specific location into MAR and  load the data into MDR register. It also set the R&#x2F;W line to 0.</li><li>Memory：When the data have been written, it responses processor  with MFC signal.</li></ul></li></ul></li></ul><h3 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h3><ul><li><p>外存(Secondary Storage)：计算机中不能直接被处理器访问的存储器，也称为辅助存储器（Auxiliary Storage）或外部存储器（External Memory）。</p><ul><li><p>外存可以长期保存大量的数据或程序，以供计算机使用。</p></li><li><p>外存的速度比内存：读写速度慢，容量更大，价格更低。</p></li></ul></li><li><p>外存的类型有很多，常见的有硬盘（Hard Disk）、固态硬盘（Solid State Drive）、U盘（Thumb Drive）、SD卡（SD Card）、光盘（Optical Disc）等。</p><ul><li><p>硬盘（<strong>Hard Disk</strong>）是一种利用磁性材料记录数据的外存，也叫做磁盘。它由一个或多个金属盘片组成，每个盘片都覆盖了磁性材料。硬盘通过一个机械臂上的磁头来读写数据，磁头可以在盘片上移动到不同的位置。硬盘的容量很大，但是速度较慢，而且易受物理损坏。</p></li><li><p>固态硬盘（<strong>Solid State Drive</strong>）是一种利用闪存芯片记录数据的外存，也叫做闪存盘。它没有任何机械部件，因此速度很快，而且抗震性强。固态硬盘的容量较小，但是价格较高，而且有写入次数的限制。</p></li><li><p>U盘（<strong>Thumb Drive</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做USB驱动器。它可以通过USB接口连接到计算机上，实现数据的传输和存储。U盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。U盘的优点是方便携带和使用，缺点是易丢失和损坏。</p></li><li><p>SD卡（<strong>SD Card</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做安全数字卡。它可以通过SD卡插槽连接到计算机或其他设备上，实现数据的传输和存储。SD卡的容量和速度各有不同，但是都比U盘小得多。SD卡的优点是体积小巧和兼容性强，缺点是易损坏和丢失。</p></li><li><p>光盘（<strong>Optical Disc</strong>）是一种利用光学原理记录数据的外存，也叫做光学数字媒体。它由一个或多个塑料圆盘组成，每个圆盘都覆盖了一层反射材料。光盘通过一个激光头来读写数据，激光头可以在圆盘上移动到不同的位置。光盘的类型有很多，常见的有CD（Compact Disc）、DVD（Digital Versatile Disc）、BD（Blu-ray Disc）等。光盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。光盘的优点是成本低廉和寿命长久，缺点是易刮花和损坏。</p></li></ul></li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li>MAR(Memory Address Register) 存储器地址寄存器</li><li>MDR(Memory Data Register) 存储器数据寄存器</li></ul><h3 id="存储单元和地址"><a href="#存储单元和地址" class="headerlink" title="存储单元和地址"></a>存储单元和地址</h3><ul><li><p>Word（字）：每一组固定大小的<strong>bit</strong>称为一个字。</p></li><li><p>Word Length（字长）：每个字的位数称为字长。它通常在16位到64位之间</p></li><li><p>Byte(字节)：$1 byte &#x3D; 8 bit$ byte是KB，MB，GB中的B。</p><ul><li>K: $2^{10},1024$  </li><li>M：$2^{20},1046576$ </li><li>G：$2^{30},1073741824$</li></ul></li></ul><p>计算机存储器图表表示：</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231010165617847.png" alt="image-20231010165617847"></p><p>大端赋值</p><h3 id="字节排序"><a href="#字节排序" class="headerlink" title="字节排序"></a>字节排序</h3><p>多字节数据类型（如整数、浮点数等）在内存中的字节排列顺序。它决定了在内存中的哪个字节存储数据的最低有效位（低位）和最高有效位（高位）。字节排序有两种常见的方式：大端序（Big-endian）和小端序（Little-endian）。</p><h4 id="大端赋值（Big-Endian）"><a href="#大端赋值（Big-Endian）" class="headerlink" title="大端赋值（Big-Endian）"></a>大端赋值（Big-Endian）</h4><ul><li>在大端字节顺序中，最高有效字节（Most Significant Byte，MSB）位于内存地址的最低端（低地址端）</li><li>最低有效字节（Least Significant Byte，LSB）位于内存地址的最高端（高地址端）。</li><li>这意味着在大端字节顺序下，数据的各个字节按照从高位到低位的顺序存储，与日常习惯从左到右读数的顺序相同。</li></ul><p><a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">大端赋值（从左到右）是一种在内存中存储数据的方式，其中最高有效字节（MSB）放在最低的内存地址，而最低有效字节（LSB）放在最高的内存地址。这意味着字节的存储顺序与我们从左到右读取它们的顺序相同。</a> </p><p>例如，如果我们想要将十六进制数 0x12345678 存储在一个 4 字节的内存位置，我们将按照以下方式分配字节：</p><table><thead><tr><th align="left">内存地址</th><th align="left">字节值</th></tr></thead><tbody><tr><td align="left">0x1000</td><td align="left">0x12</td></tr><tr><td align="left">0x1001</td><td align="left">0x34</td></tr><tr><td align="left">0x1002</td><td align="left">0x56</td></tr><tr><td align="left">0x1003</td><td align="left">0x78</td></tr></tbody></table><p><a href="https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/">这也被称为大端字节序或网络字节序，因为它通常用于网络协议，如 TCP&#x2F;IP。</a> </p><p>大端赋值的一些优点是：</p><ul><li><a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">它更容易阅读和调试，因为数据的存储顺序与我们写它的顺序相同。</a></li><li><a href="https://teaching.idallen.com/cst8281/10w/notes/110_byte_order_endian.html">它与我们在数学中表示数字的方式一致，其中最高有效位在左边。</a></li><li><a href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它简化了算术运算，如加法和减法，因为进位或借位从右到左传播。</a></li></ul><p>大端赋值的一些缺点是：</p><ul><li><a href="https://stackoverflow.com/questions/26204333/little-endian-and-big-endian">它与一些使用小端赋值的处理器不兼容，其中 LSB 在最低的内存地址，而 MSB 在最高的内存地址。这在不同系统之间交换数据时可能会导致问题。</a></li><li><a href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它在处理数组或矩阵时可能会引起混淆，因为索引顺序可能与字节顺序不匹配。例如，在 Verilog 中，一个声明为 <code>reg [3:0] array1 [0:7]</code> 的数组具有大端位顺序，但小端索引顺序。</a></li></ul><h4 id="小端赋值"><a href="#小端赋值" class="headerlink" title="小端赋值"></a>小端赋值</h4><ul><li>在小端序中，最低有效字节（低位字节）存储在内存的最低地址。</li><li>最高有效字节（高位字节）存储在内存的最高地址。</li><li>这种字节排序方式类似于我们书写数字的方式，从右到左。</li><li>小端序在一些体系结构（如x86、ARM、网络通信协议中的小端序）中使用。</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
