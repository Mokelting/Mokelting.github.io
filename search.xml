<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从零开始的Java</title>
      <link href="/2023/10/12/cong-ling-kai-shi-de-java/"/>
      <url>/2023/10/12/cong-ling-kai-shi-de-java/</url>
      
        <content type="html"><![CDATA[<h1 align = center> JAVA </h1><h2 id="字面量："><a href="#字面量：" class="headerlink" title="字面量："></a>字面量：</h2><p><img src="E:\DeskTable\博客学习截图传输\image-20230921152649653.png" alt="image-20230921152649653"></p><h2 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h2><p>栈：方法运行时使用内存</p><p>堆：存储数据和对象以及new创建的对象和数据，new多少次开辟几次空间</p><p>方法区：存储可执行的class文件</p><p>本地方法栈：JVM使用操作系统功能时使用</p><p>寄存器：CPU调度使用</p><img src="E:\DeskTable\博客学习截图传输\image-20231006111238285.png" alt="image-20231006111238285" style="zoom: 50%;" /><p>JDK8以后：</p><p>栈</p><p>堆</p><p>元空间</p><p>本地方法栈</p><p>寄存器</p><img src="E:\DeskTable\博客学习截图传输\image-20231006111224616.png" alt="image-20231006111224616" style="zoom:50%;" />  <h3 id="阿里的检查插件"><a href="#阿里的检查插件" class="headerlink" title="阿里的检查插件"></a>阿里的检查插件</h3><p><a href="https://blog.csdn.net/lizz861109/article/details/109027594">idea安装阿里代码检查工具（Alibaba Java Coding Guidelines）_alibaba java coding guidelines plugin support.-CSDN博客</a></p><p>Java 本身有数组对象,new一个数组对象,也是固定的大小,插删</p><p>使用了一个集合类型，可能存在内存泄漏</p><p>直接销毁集合对象，但是集合内的数据尚未释放</p><p>Java 底层并没有泛型概念，是后期拓展出的功能</p><p>异常处理！！！实际项目很重要</p><h1 id="抽象类和-接口"><a href="#抽象类和-接口" class="headerlink" title="抽象类和&#x3D;&#x3D;接口&#x3D;&#x3D;"></a>抽象类和&#x3D;&#x3D;接口&#x3D;&#x3D;</h1><p>Java只支持单继承</p><p>对比：</p><ul><li>c++有纯虚函数的概念：函数原型——函数的声明和实现分离</li><li>Java没有</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的离散数学</title>
      <link href="/2023/10/12/chi-san-shu-xue/"/>
      <url>/2023/10/12/chi-san-shu-xue/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的大学物理</title>
      <link href="/2023/10/11/da-xue-wu-li/"/>
      <url>/2023/10/11/da-xue-wu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="14章-静电场"><a href="#14章-静电场" class="headerlink" title="14章 静电场"></a>14章 静电场</h1><h2 id="14-1-电荷-库仑定律"><a href="#14-1-电荷-库仑定律" class="headerlink" title="14-1 电荷 库仑定律"></a>14-1 电荷 库仑定律</h2><h3 id="1-电荷量子化"><a href="#1-电荷量子化" class="headerlink" title="1. 电荷量子化"></a>1. 电荷量子化</h3><ol><li><p>种类：正电荷、负电荷</p></li><li><p>性质：同性相斥、异性相吸</p></li><li><p>单位：库伦（C）</p></li><li><p>量子化： $q&#x3D;\pm ne$ </p><p>​   $e&#x3D;1.602\times10^{-19}$</p></li></ol><h3 id="2-电荷守恒定律："><a href="#2-电荷守恒定律：" class="headerlink" title="2. 电荷守恒定律："></a>2. 电荷守恒定律：</h3><p>不管系统中的电荷如何迁移，孤立系统的电荷的代数和保持不变（自然界的基本守恒定律之一）</p><h4 id="3-库仑定律："><a href="#3-库仑定律：" class="headerlink" title="3. 库仑定律："></a>3. 库仑定律：</h4><ul><li><p>真空中两个静止点电荷 相互作用力<strong>F</strong>的大小与这两个点电荷所带电荷 量 $q_1$ 和 $q_2$ 的乘积成正比， 与它们之间的距离<strong>r</strong>的平 方成反比</p></li><li><p>点电荷：抽象模型</p></li><li><p>库仑力大小为: $F &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{q_1q_2}{r^2}$ 方向:同号相斥,异号相吸 </p></li><li><p>真空电容率: $\epsilon_0 &#x3D; 8.85\times10^{-12} C^2\cdot m^{-2}$ </p></li><li><p>两个以上的静止点电荷采用<strong>静电力的叠加原理</strong>:</p><ul><li>作用于每一个电荷上的总静电力等于其他点电荷单独存在时作 用于该电荷的静电力的矢量和。</li><li><img src="E:\DeskTable\博客学习截图传输\image-20231011095200807.png" alt="image-20231011095200807" style="zoom:67%;" /></li></ul></li></ul><h2 id="14-2-电场-电场强度"><a href="#14-2-电场-电场强度" class="headerlink" title="14-2 电场 电场强度"></a>14-2 电场 电场强度</h2><h3 id="1-静电场"><a href="#1-静电场" class="headerlink" title="1. 静电场"></a>1. 静电场</h3><img src="E:\DeskTable\博客学习截图传输\image-20231011095349585.png" alt="image-20231011095349585" style="zoom:50%;" /><h3 id="2-电场强度"><a href="#2-电场强度" class="headerlink" title="2. 电场强度"></a>2. 电场强度</h3><ul><li><p>电场中某点处的电场强度等于位于该点处的单位试验电荷 所受的力，其<strong>方向为正电荷受力方向</strong>.</p></li><li><p>电场强度大小:$E&#x3D;\frac{F}{q_0}$ </p></li><li><p>单位: $N \cdot C^{-1}$ 或 $V \cdot m^{-1}$ </p></li><li><p>电荷在电场中受力: $F&#x3D;qE$</p></li></ul><h3 id="3-点电荷电场强度"><a href="#3-点电荷电场强度" class="headerlink" title="3. 点电荷电场强度"></a>3. 点电荷电场强度</h3><p>知识点和高中相似</p><p>$F &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{Qq_0}{r^2}$$E &#x3D; \frac{F}{q_0} &#x3D; \frac{1}{4\pi{\epsilon}_0}\frac{Q}{r^2}$</p><h3 id="4-电场强度叠加原理"><a href="#4-电场强度叠加原理" class="headerlink" title="4. 电场强度叠加原理"></a>4. 电场强度叠加原理</h3><p>4-1 点电荷$q_i$ 对 $q_0$ ,在$q_0$ 处的总电场强度:</p><ul><li>与静电力的叠加原理类似,某个电荷之外的其他电荷在该电荷的电场等于每一个电场强度的矢量和:</li><li>$\vec{E} &#x3D; \sum_i \vec{E_i} $</li></ul><p>4-2 连续电荷在某一点的总电场强度:</p><img src="E:\DeskTable\博客学习截图传输\image-20231011100812868.png" alt="image-20231011100812868" style="zoom:50%;" /><p>$d\vec{E} &#x3D; \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r}$$\vec{E} &#x3D; \int d \vec{E} &#x3D; \int \frac{1}{4 \pi \epsilon_0} \frac{dq}{r^2} \vec{e_r} $</p><p>体密度: $\rho &#x3D; \frac{dq}{dV}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011101609517.png" alt="image-20231011101609517" style="zoom:50%;" /></p><p>面密度: $\sigma &#x3D; \frac{dq}{dS}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011101549342.png" alt="image-20231011101549342" style="zoom: 50%;" /></p><p>线密度: $ \lambda &#x3D; \frac{dq}{dl} $ <img src="E:\DeskTable\博客学习截图传输\image-20231011101526062.png" alt="image-20231011101526062" style="zoom: 50%;" /></p><h3 id="5-外电场对电偶极子的力矩和取向作用"><a href="#5-外电场对电偶极子的力矩和取向作用" class="headerlink" title="5. 外电场对电偶极子的力矩和取向作用"></a>5. 外电场对电偶极子的力矩和取向作用</h3><img src="E:\DeskTable\博客学习截图传输\image-20231011101656283.png" alt="image-20231011101656283" style="zoom:150%;" /><p>相距很近,等量异号的点电荷系:</p><p>​电距: $\vec{P} &#x3D; q \vec{l} $</p><img src="E:\DeskTable\博客学习截图传输\image-20231011102016383.png" alt="image-20231011102016383" style="zoom: 67%;" /><p>匀强电场中:</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231011102128247.png" alt="image-20231011102128247"></p><p>$\vec{F} &#x3D; \vec{F_+} + \vec{F_-} &#x3D; q\vec{E} - q\vec{E} &#x3D; 0$</p><p>$M &#x3D; q r_0 E \sin{\theta} &#x3D; pE\sin{\theta}$ </p><p>$\vec{M} &#x3D; \vec{p} \times \vec{E} \left{<br>\begin{array}{l}<br>\theta &#x3D; 0 \<br>\theta &#x3D; \pi<br>\end{array}<br>\right.$$\vec{M} &#x3D; 0$</p><h2 id="14-3-电场强度通量-高斯定理"><a href="#14-3-电场强度通量-高斯定理" class="headerlink" title="14-3 电场强度通量 高斯定理"></a>14-3 电场强度通量 高斯定理</h2><h3 id="1-电场线"><a href="#1-电场线" class="headerlink" title="1. 电场线"></a>1. 电场线</h3><p>为了直观可视化描述电场</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231011103714950.png" alt="image-20231011103714950"></p><ul><li>曲线上每一点切线方向为该点电场方向</li><li>通过垂直于电场方向单位面积的电场线的条数为该电场强度的大小      $|\vec{E}| &#x3D; E &#x3D; \frac{dN}{dS_{\perp}}$</li></ul><p>多种点电荷电场线,与高中无异</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>始于正电荷,终于负电荷(来自无穷远,去向无穷远) 在没有电荷的地方不中断</li><li>没有电荷的地方任意两条电场线不相交</li><li>电场线不闭合</li><li>电场线密集——电场强度较大；电场线稀疏——电场强度较小</li></ol><h3 id="2-电场强度通量"><a href="#2-电场强度通量" class="headerlink" title="2. 电场强度通量"></a>2. 电场强度通量</h3><p>通过电场中某一个面的电场线数叫做通过这个面的电场强度通量</p><ul><li><p>匀强电场:</p><ul><li><p>$\vec{E}$ 与平面垂直</p><p>$\Phi_e &#x3D; ES$ <img src="E:\DeskTable\博客学习截图传输\image-20231011104246049.png" alt="image-20231011104246049"  /> </p></li><li><p>$\vec{E} $ 与平面夹角为$\theta$<br>$\Phi_e &#x3D; ES \cos{\theta} $$\Phi_e &#x3D; \vec{E} \cdot \vec{S}$ <img src="E:\DeskTable\博客学习截图传输\image-20231011104550268.png" alt="image-20231011104550268"></p></li></ul></li><li><p>非均匀电场</p><ul><li><p>$ d \vec{S} &#x3D; dS \cdot \vec{e_n}$</p></li><li><p>$ d\Phi_e &#x3D; \vec{E} \cdot d \vec{S} $</p></li><li><p>$ \Phi_e &#x3D; \int d \Phi_e &#x3D; \int_S E \cos{\theta} dS $</p></li><li><p>$ \Phi_e &#x3D; \int_S \vec{E} \cdot d\vec{S} $</p></li><li><p><img src="E:\DeskTable\博客学习截图传输\image-20231011105921724.png" alt="image-20231011105921724"></p></li><li><p>S为封闭曲面时:</p><ul><li><p>$\theta_1 &lt; \frac{\pi}{2} , d\Phi_{e1} &gt; 0 $</p></li><li><p>$ \theta_2 &gt; \frac{\pi}{2}, d\Phi_{e2} &lt; 0$</p></li><li><p><img src="E:\DeskTable\博客学习截图传输\image-20231011105912608.png" alt="image-20231011105912608"></p></li></ul></li><li><p>闭合曲面的电场强度通量</p><ul><li>$ d\Phi_e &#x3D; \vec{E} \cdot d \vec{S} $</li><li>$ \oint_S \vec{E} \cdot d \vec{S} &#x3D; \oint_S E \cos{\theta} dS $</li><li><img src="E:\DeskTable\博客学习截图传输\image-20231011105852809.png" alt="image-20231011105852809"></li></ul></li></ul></li></ul><h3 id="3-高斯定理"><a href="#3-高斯定理" class="headerlink" title="3. 高斯定理"></a>3. 高斯定理</h3><p>在真空中,通过任一闭合曲面的电场强度通量, 等于该曲面所包围的所有电荷的代数和除以 $\epsilon_0$ （与面外电荷无关，闭合曲面称为高斯面）</p><p>$ \Phi_e &#x3D; \oint_S \vec{E} \cdot d \vec{S} &#x3D; \frac{1}{\epsilon_0} \sum^n_{i&#x3D;1} q_i^{in}$  </p><p>由<strong>库仑定律</strong>和<strong>电场强度叠加原</strong>理可以导出<strong>高斯定理</strong></p><ul><li><p>闭合面外的电荷对通过闭合 面的电场强度通量没有贡献，但是对闭合面上各点的电场强度是有贡献的，即闭合面上各点的电场强度是由闭合面内、外所有电 荷共同激发的</p></li><li><p>高斯定理将静电场与场源电荷联系了起来，揭示了静电场是有源场这一普遍性质(静电场有源无旋)</p></li></ul><h3 id="4-高斯定理的应用"><a href="#4-高斯定理的应用" class="headerlink" title="4. 高斯定理的应用"></a>4. 高斯定理的应用</h3><p>应用条件:</p><ol><li><p>静电场必须具有一定的对称性</p></li><li><p>根据对称性选择高斯面</p></li><li><p>高斯面上的场强处处相等或者分区域相等;</p><p>部分高斯面上的通量为零,部分高斯面上的场强相等</p></li><li><p>先使用高斯定理求出电场强度通量,而后用高斯定理,配合闭合曲面大小求出电场强度</p></li></ol><h2 id="14-4-静电场的环路定理-电势"><a href="#14-4-静电场的环路定理-电势" class="headerlink" title="14-4 静电场的环路定理 电势"></a>14-4 静电场的环路定理 电势</h2><h4 id="1-静电场力所做的功"><a href="#1-静电场力所做的功" class="headerlink" title="1. 静电场力所做的功"></a>1. 静电场力所做的功</h4><p>点电荷的电场</p><p>$dA &#x3D; q_0 \vec{E} \cdot \vec{l} &#x3D; q_0E \cdot dl \cdot \cos{\theta} $</p><p>​  $&#x3D;q_0 \frac{q}{4 \pi \epsilon_0 r^2} \cdot dl \cdot \cos{\theta} $</p><p>$dl \cos{\theta} &#x3D; dr$</p><p>$dA &#x3D; \frac{q_0q}{4 \pi \epsilon_0 r^2} dr$</p><p>$A&#x3D; \frac{q_0q}{4 \pi \epsilon_0} \int^{r_B}_{r_A} \frac{dr}{r^2} &#x3D; \frac{q_0q}{4 \pi \epsilon_0}(\frac{1}{r_A} - \frac{1}{r_B})$</p><p>所做的功<strong>A</strong> 仅和 $q_0$ 的始末位置有关,与路径无关(积分与路径无关)</p><p>即可得:</p><p>$ \vec{E} &#x3D; \sum \vec{E_i} $ (点电荷的组合)</p><p>$ A &#x3D; \int_l q_0 \vec{E} \cdot d \vec{l} &#x3D; \sum_i q_0 \cdot \int_l \vec{E_i} \cdot d \vec{l} $</p><img src="E:\DeskTable\博客学习截图传输\image-20231011121105020.png" alt="image-20231011121105020" style="zoom: 67%;" /><h4 id="2-静电场的环路定理"><a href="#2-静电场的环路定理" class="headerlink" title="2. 静电场的环路定理"></a>2. 静电场的环路定理</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20231011123130536.png" alt="image-20231011123130536"></p><p>$ q_0 \int_{ABC} \vec{E} \cdot d \vec{l} &#x3D; q_0 \int_{ADC} \cdot d \vec{l} $</p><p>$ q_0(\int_{ABC} \vec{E} \cdot d \vec{l} - \int_{ADC} \vec{E} \cdot d \vec{l}) &#x3D; 0 $</p><p>静电场是保守场,沿闭合路径一周,电场力做功为零</p><h1 id="16章-稳恒磁场"><a href="#16章-稳恒磁场" class="headerlink" title="16章 稳恒磁场"></a>16章 稳恒磁场</h1><h2 id="16-1"><a href="#16-1" class="headerlink" title="16-1"></a>16-1</h2><h3 id="1-电流电流密度"><a href="#1-电流电流密度" class="headerlink" title="1. 电流电流密度"></a>1. 电流电流密度</h3><h4 id="1-1形成电流的条件："><a href="#1-1形成电流的条件：" class="headerlink" title="1.1形成电流的条件："></a>1.1形成电流的条件：</h4><ul><li><p>在导体内有可以自由移动的电荷（载流子） </p></li><li><p>在导体内要维持一个电场，或者在导体两端要存在有电势差\</p></li></ul><p><img src="E:\DeskTable\博客学习截图传输\image-20231011192022160.png" alt="image-20231011192022160"></p><p>电流强度：通过截面<strong>S</strong>的电荷随时间的变化率</p><p>$I &#x3D; \frac{dq}{dt} $</p><p>$dq &#x3D; qnudtS$ </p><ul><li>$q$ 载流子电荷</li><li>$n$ 载流子浓度 </li><li>$\vec{u}$ 载流子漂移速度 $u$ 电子漂移速度的大小</li></ul><p>$dI &#x3D; qnudS_{\perp} &#x3D; qnudS \cos{theta} &#x3D; qn \vec{u} \cdot d \vec{S} &#x3D; \vec{j} \cdot \textbf{d} \vec{S} $  </p><p>电流密度矢量大小: $j &#x3D; \frac{dI}{d S_{\perp}} &#x3D; qnu$ 方向为该点正电荷运动方向,单位: $A \cdot m^{-2}$ </p><p>通过任意曲面的电流: $I &#x3D; \int_S \vec{j} \cdot d \vec{S}$ </p><h4 id="1-2-电流的连续性方程稳恒电流条件"><a href="#1-2-电流的连续性方程稳恒电流条件" class="headerlink" title="1.2 电流的连续性方程稳恒电流条件"></a>1.2 电流的连续性方程稳恒电流条件</h4><p>单位时间内通过闭合曲面向外流出的电荷，等于此时间内闭合曲面内电荷的减少量.</p><p>电流密度矢量点乘闭合曲面面积矢量微元即是此刻在该处曲面的电流的微元</p><p>$ dI &#x3D; \vec{j} \cdot d \vec{S}$ $I &#x3D; \oint_S \vec{j} \cdot d \vec{S} &#x3D; \frac{dq_外}{dt} &#x3D; -\frac{dq_内}{dt} $</p><p>某一时刻,单位闭合曲面 <em>S</em> 内,流入的电荷量与流出的电荷量相互抵消——即闭合曲面 <em>S</em> 内部的电荷不随时间的变化而变化，则</p><p>$ \frac{d q_内}{dt} &#x3D; 0$ </p><p>稳恒电流$ \oint_S \vec{j} \cdot d \vec{S} &#x3D; 0$ </p><p>导体内的电流密度不随时间变化的电流</p><img src="E:\DeskTable\博客学习截图传输\image-20231011201203610.png" alt="image-20231011201203610" style="zoom:50%;" /><p>由基尔霍夫第一定律:$ -I+I_1+I_2&#x3D;0 $ </p><ol><li>在稳恒电流情况下，导体中电荷分布不随时间变化形成恒定电场</li><li>稳恒电场与<mark>静电场具有相似性质</mark>（高斯定理和环路定理），同时稳恒电场引入了电势概念</li><li>稳恒电场存在<mark>能量的转换</mark>（很正常，带电体在电场内会做功或者被做功，则必然伴随着$势能 \rightleftharpoons 动能$）</li></ol><p>$U &#x3D; IR$ $R &#x3D; \rho \frac{l}{s}$</p><h4 id="1-3-欧姆定律的微分形式"><a href="#1-3-欧姆定律的微分形式" class="headerlink" title="1.3 欧姆定律的微分形式"></a>1.3 欧姆定律的微分形式</h4><img src="E:\DeskTable\博客学习截图传输\image-20231012000103917.png" alt="image-20231012000103917" style="zoom:67%;" /><p>$dI &#x3D; \frac{dU}{R}$$R &#x3D; \frac{\rho dl}{dS} $</p><p>$dI &#x3D; \frac{1}{\rho} \frac{dU}{dl} dS$</p><p>$\frac{dI}{dS} &#x3D; \frac{1}{\rho} \frac{dU}{dl} &#x3D; \frac{1}{\rho} E &#x3D; \sigma E$</p><p>$\vec{j} &#x3D; \frac{dI}{dS} &#x3D; \frac{1}{\rho} \vec{E} &#x3D; \sigma \vec{E}$</p><p>非静电力：能不断分离正负电荷使正电荷逆静电场力方向运动</p><p>电源：提供非静电力的装置</p><p>非静电电场强度 $\vec{E_k}$ : 为单位正电荷所受的非静电力.</p><p>$A_非 &#x3D; \int^+_- q \vec{E_k} \cdot d \vec{l} $</p><p>电动势的定义：单位正电荷从负极通过电源内部移到正极时非静电力所做的功.</p><p>电动势是电路中电荷流动的驱动力</p><img src="E:\DeskTable\博客学习截图传输\image-20231012081945376.png" alt="image-20231012081945376" style="zoom:50%;" /><p>计算电动势的两种不同描述:</p><ol><li><p>基于电荷在已知电场中的移动</p><ul><li>这个公式表示了电场 $\vec{E_k}$ 在电荷 $q$ 移动的路径上执行的功，然后将这个功除以电荷的大小 $q$，得到电动势 $\epsilon$。这是电动势的一种定义方式，其中 $\vec{E_k}$ 是电场力，$d\vec{l}$ 是电荷移动路径上的微小位移，而 $\int_{+}^{-}$ 表示要对电荷从一个点移动到另一个点的路径上进行积分。</li><li>$ \epsilon &#x3D; \frac{A_非}{q} &#x3D; \int^+_- \vec{E_k} \cdot d \vec{l}$</li></ul><p></p></li><li><p>考虑电荷周围存在其他电场情况</p><ul><li>这个公式表示电场 $\vec{E_k}$ 和一个额外电场 $\vec{E}$ 一起对电荷 $q$ 执行的功的总和。在这里，$\vec{E_k}$ 是由于电荷本身产生的电场，而 $\vec{E}$ 可能是由外部因素产生的电场，如其他电荷或电场源。这个公式采用了环路积分的形式，表示对电荷沿着闭合路径 $l$ 移动时，电场 $\vec{E_k}$ 和 $\vec{E}$ 执行的总功。</li><li>$\epsilon &#x3D; \oint_l (\vec{E_k} + \vec{E}) \cdot d \vec{l}$</li></ul></li></ol><h2 id="16-2-磁场和磁感应强度"><a href="#16-2-磁场和磁感应强度" class="headerlink" title="16-2 磁场和磁感应强度"></a>16-2 磁场和磁感应强度</h2><h3 id="1-磁感应强度"><a href="#1-磁感应强度" class="headerlink" title="1. 磁感应强度"></a>1. 磁感应强度</h3><h4 id="1-1磁感应强度的定义"><a href="#1-1磁感应强度的定义" class="headerlink" title="1.1磁感应强度的定义:"></a>1.1磁感应强度的定义:</h4><p>当正电荷垂直于特定直线运动时，受力$\vec{F_{max}}$ 将$\vec{F_{max}} \times \vec{v}$ 方向定义为该点的$ \vec{B}$ 的方向.</p><p>磁感强度大小: $B&#x3D;\frac{F_{max}}{qv} $</p><p>运动电荷在磁场中受力(洛伦兹力),受力大小为:<br>$ \vec{F} &#x3D; q \vec{v} \times \vec{B}$ </p><img src="E:\DeskTable\博客学习截图传输\image-20231012083921021.png" alt="image-20231012083921021" style="zoom:50%;" /><p>单位:特斯拉 $ 1T &#x3D; 1 N \cdot (A \cdot m)^{-1}$</p><h4 id="1-2-磁感线-有旋无源"><a href="#1-2-磁感线-有旋无源" class="headerlink" title="1.2 磁感线(有旋无源)"></a>1.2 磁感线(有旋无源)</h4><ol><li>理想模型,规定:曲线上每一点的切线方向就是该点的磁感强度<em>B</em>的方向,曲线的疏密程度表示该点的磁感强度<em>B</em>的大小.</li></ol><img src="E:\DeskTable\博客学习截图传输\image-20231012084013228.png" alt="image-20231012084013228" style="zoom:67%;" /><ol start="2"><li>性质:<ul><li>与电流套连 </li><li>闭合曲线 </li><li>方向与电流成右手螺旋关系</li></ul></li></ol><h2 id="16-3-毕奥-萨伐尔定律-磁生电"><a href="#16-3-毕奥-萨伐尔定律-磁生电" class="headerlink" title="16-3 毕奥-萨伐尔定律(磁生电)"></a>16-3 毕奥-萨伐尔定律(磁生电)</h2><p>电流元在空间产生的磁场</p><img src="E:\DeskTable\博客学习截图传输\image-20231012091229844.png" alt="image-20231012091229844" style="zoom:50%;" /><p>$dB &#x3D; \frac{\mu_0}{4 \pi} \frac{I dl \sin{\theta}}{r^2}$$\rightarrow$$d\vec{B} &#x3D; \frac{\mu_0}{4 \pi} \frac{I d\vec{l} \times \vec{r}}{r^3} $</p><p>$\mu_0 为真空电导率,\mu_0 &#x3D; 4 \pi \times 10^{-7} N \cdot A^{-2}$</p><p>任意载流导线在点 <strong>P</strong> 处的磁感强度</p><p>磁感强度叠加:$\vec{B} &#x3D; \int d \vec{B} &#x3D; \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \vec{r}}{r^3} &#x3D; \int \frac{\mu_0 I}{4 \pi} \frac{d \vec{l} \times \hat{r}}{r^2} $ </p><ol><li><p>$\vec{B}$ 表示磁场矢量，它是一个矢量，表示在某个点上的磁场强度和方向。</p></li><li><p>$\int d\vec{B}$ 表示对磁场矢量 $\vec{B}$ 进行积分，通常表示对整个区域的磁场进行积分以获得某一点的总磁场。</p></li><li><p>$\mu_0$ 是真空磁导率。</p></li><li><p>$I$ 表示电流，它是电流环中的电流。</p></li><li><p>$d\vec{B}$ 表示磁场小微元，即微小部分的磁场，通常由微小电流元素产生。</p></li><li><p>$\vec{r}$ 是位置矢量，表示观察点到电流元素的距离。</p></li><li><p>$d\vec{l}$ 表示电流元素的微小位移，即在电流环上的微小长度元素。</p></li><li><p>$\times$ 表示矢量叉积，产生一个垂直于 $d\vec{l}$ 和 $\vec{r}$ 的磁场矢量。</p></li><li><p>$r$ 表示观察点到电流微元的距离大小。</p></li><li><p>$\hat{r}$ 是单位矢量，指向观察点到电流元素的方向。</p><p>一个非零向量 $\vec{r}$的 <strong>正规化向量</strong> $\hat{r}$ 就是平行于$\vec{r}$的单位向量： $\hat{r} &#x3D; \frac{r}{|| \vec{r} ||}$</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的web开发</title>
      <link href="/2023/10/09/cong-ling-kai-shi-de-web-kai-fa/"/>
      <url>/2023/10/09/cong-ling-kai-shi-de-web-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 align=center> 从零开始的web开发 </h1><h1 id="从零开始的web开发"><a href="#从零开始的web开发" class="headerlink" title="从零开始的web开发"></a>从零开始的web开发</h1><p>HTML 定义网页内容</p><p>CSS 描述网页布局</p><p>JavaScript 控制网页行为</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>其实和<strong>markdown</strong>没什么大区别</p><h3 id="定义及特点"><a href="#定义及特点" class="headerlink" title="定义及特点"></a>定义及特点</h3><ul><li>超文本标记语言：Hyper Text Markup Language</li><li>HTML是一种标记语言<ul><li>标记语言即是一套标记标签</li></ul></li><li>使用标记标签来描述网页</li><li>HTML文档包含了HTML标签及文本内容</li><li>HTML文档也称为<strong>web</strong>页面</li></ul><p>一个完整的HTML页面：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span> //声明为HTML5文档//头部元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>//HTML页面的根元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>//包含了文档的元(meta)数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>示例() <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>//可见的页面内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span> 一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span> 一个段落<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的电子电路</title>
      <link href="/2023/09/20/cong-ling-kai-shi-de-dian-gong/"/>
      <url>/2023/09/20/cong-ling-kai-shi-de-dian-gong/</url>
      
        <content type="html"><![CDATA[<h1 align = center> 电工学 </h1><h2 id="2-5-结点电压法"><a href="#2-5-结点电压法" class="headerlink" title="2.5 结点电压法"></a>2.5 结点电压法</h2><h3 id="2-5-0-基本概念："><a href="#2-5-0-基本概念：" class="headerlink" title="2.5.0 基本概念："></a>2.5.0 基本概念：</h3><h2 id="2-7-戴维宁定理和诺顿定理"><a href="#2-7-戴维宁定理和诺顿定理" class="headerlink" title="2.7 戴维宁定理和诺顿定理"></a>2.7 戴维宁定理和诺顿定理</h2><h3 id="2-7-0-基本概念："><a href="#2-7-0-基本概念：" class="headerlink" title="2.7.0 基本概念："></a>2.7.0 基本概念：</h3><h4 id="二端网络："><a href="#二端网络：" class="headerlink" title="二端网络："></a>二端网络：</h4><p>有源——有电源</p><p>无源——无电源</p><img src="E:\DeskTable\博客学习截图传输\image-20230920171844352.png" alt="image-20230920171844352" style="zoom:50%;" /><p><strong>采取的均是等效思想，等效出的电路图对于外部电路效果相同，但是内部并不一定相同</strong></p><h4 id="无源二端网络："><a href="#无源二端网络：" class="headerlink" title="无源二端网络："></a>无源二端网络：</h4><p>因没有电源，只需将各部分支路的电阻通过电阻串并联的规律进行等效变换、化简为一个电阻，再与二端网络之外的电阻放在电路图当中进行讨论即可</p><img src="E:\DeskTable\博客学习截图传输\image-20230920171932963.png" alt="image-20230920171932963" style="zoom:50%;" /><h4 id="有源二端网络："><a href="#有源二端网络：" class="headerlink" title="有源二端网络："></a>有源二端网络：</h4><p>两个定理重点讨论的对象</p><img src="E:\DeskTable\博客学习截图传输\image-20230920172618732.png" alt="image-20230920172618732" style="zoom:50%;" /><p>相对于$R_3$而言，不管$E和R_1和R_2和I_s$有多么复杂，都可以视作一个大电源。则易于进行电路的分析。</p><p>无论是恒压源还是恒流源均可，对于外部电路的分析而言并无太大区别，重要的是将复杂的电路进行简单化。</p><img src="E:\DeskTable\博客学习截图传输\image-20230920172810819.png" alt="image-20230920172810819" style="zoom:50%;" /><img src="E:\DeskTable\博客学习截图传输\image-20230920173220030.png" alt="image-20230920173220030" style="zoom:50%;" /><h3 id="2-7-1-戴维宁定理："><a href="#2-7-1-戴维宁定理：" class="headerlink" title="2.7.1 戴维宁定理："></a>2.7.1 戴维宁定理：</h3><p>任何一个有源二端线性网络都可以用一个电压源来等效代替——电动势为E、内阻为$R_0$ </p><p>求出E和$R_0$的方法</p><img src="E:\DeskTable\博客学习截图传输\image-20230920173739240.png" alt="image-20230920173739240" style="zoom: 67%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>离散课堂活动案例总结</title>
      <link href="/2023/09/18/chi-san-zuo-ye/"/>
      <url>/2023/09/18/chi-san-zuo-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="案例1-命题逻辑与推理规则"><a href="#案例1-命题逻辑与推理规则" class="headerlink" title="案例1(命题逻辑与推理规则)"></a>案例1(命题逻辑与推理规则)</h1><p>当涉及到笔记本电脑的决策和使用时，你同样可以使用命题逻辑和推理规则来帮助做出决策。以下是一个与笔记本电脑相关的案例：</p><p><strong>案例：选择一台笔记本电脑</strong></p><p>你正在考虑购买一台新的笔记本电脑，但市场上有许多不同的品牌和型号可供选择。你可以使用命题逻辑和推理规则来帮助你决定哪台笔记本电脑最适合你的需求。</p><p>命题：</p><ul><li>A: <strong>处理器（CPU）</strong>：处理器是笔记本电脑的大脑，影响计算性能。更高速度和更多核心的处理器通常表示更好的性能。了解处理器的型号和性能评测可以帮助你判断其性能水平。</li><li>B: <strong>内存（RAM）</strong>：内存决定了你能同时运行多少应用程序以及处理大型文件的能力。通常，8GB或更多的RAM对于一般办公和多任务处理足够了，但对于专业图形设计或游戏等任务，16GB或更多可能更合适。</li><li>C: <strong>存储设备</strong>：存储设备包括固态硬盘（SSD）和传统硬盘驱动器（HDD）。SSD比HDD更快，响应更迅速，因此通常更受欢迎。如果你需要更大的存储空间，可以选择具有大容量HDD的笔记本电脑，或者选择具有SSD和HDD组合的双存储笔记本。</li><li>D: <strong>图形处理器（GPU）</strong>：如果你需要进行图形密集型任务，如游戏、视频编辑或3D建模，那么强大的独立GPU可能是必需的。一些轻型笔记本电脑具有集成GPU，适用于日常任务，但不适合高度图形处理的工作。</li><li>E: <strong>屏幕</strong>：屏幕质量包括分辨率、色彩准确性和亮度。高分辨率屏幕通常更适用于多媒体和图形设计任务。IPS面板通常提供更好的色彩和观看角度。</li><li>F: <strong>电池寿命</strong>：电池寿命是移动性能的关键。考虑一台具有长续航时间的笔记本电脑，特别是如果你需要在不插电的情况下工作或旅行。</li><li>G: <strong>连接选项</strong>：确保笔记本电脑具有足够的USB端口、视频输出、无线连接（如Wi-Fi和蓝牙）以及其他必要的连接选项，以满足你的需求。</li><li>H: <strong>散热系统</strong>：有效的散热系统对于长时间使用和高负载任务非常重要，以避免过热导致性能下降。</li><li>I:  <strong>机身质量和设计</strong>：机身质量和设计决定了笔记本电脑的耐用性和外观。选择具有坚固机身和符合你审美喜好的设计的笔记本电脑。</li><li>J: <strong>价格</strong>：最后，考虑你的预算。要确保你的选择在你的预算范围内，同时尽量获得最好的硬件性能和功能。</li></ul><p>推理规则：</p><ul><li>如果一台笔记本电脑的性能高、价格在预算范围内，屏幕尺寸适中，并且品牌有良好的口碑，那么它是值得购买的。这可以表示为：(A ∧ B ∧ C ∧ D) → WorthBuyingLaptop。</li><li>如果一台笔记本电脑的性能高、价格不在预算范围内，那么它可能不是最佳选择。这可以表示为：(A ∧ ¬B) → NotRecommendedLaptop。</li></ul><p>现在，你可以使用这些命题和规则来进行推理，以决定哪台笔记本电脑最适合你。例如，如果你找到一台性能高、价格在预算范围内、屏幕尺寸适中、并且品牌有良好口碑的笔记本电脑，那么根据规则1，你可以得出结论这台笔记本电脑值得购买。</p><p>这个案例展示了如何使用命题逻辑和推理规则来辅助你在选择笔记本电脑时做出明智的决策，考虑了性能、价格、屏幕尺寸和品牌口碑等因素。命题逻辑和推理规则可以帮助你权衡各种因素，以选择最符合你需求的笔记本电脑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的数据结构</title>
      <link href="/2023/09/18/cong-ling-kai-shi-de-shu-ju-jie-gou/"/>
      <url>/2023/09/18/cong-ling-kai-shi-de-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 align=center>从零开始的数据结构</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-数据结构三要素"><a href="#1-数据结构三要素" class="headerlink" title="1.数据结构三要素:"></a>1.数据结构三要素:</h3><ol><li><p>逻辑结构</p></li><li><p>存储结构（物理结构）</p></li><li><p>具体的运算，即包含基础操作：数据的访问、添加、删除、更新</p></li></ol><h3 id="2-为什么要有数据结构"><a href="#2-为什么要有数据结构" class="headerlink" title="2.为什么要有数据结构:"></a>2.为什么要有数据结构:</h3><p>数据结构的提出是为了满足实际生产需求当作遇到的数据存储空间的分配问题,良好的空间分配方式可以提高程序的效率,降低成本,提高产能,因而数据结构并不高深,取之于生活再用之于生活。</p><h2 id="二、线性数据结构"><a href="#二、线性数据结构" class="headerlink" title="二、线性数据结构"></a>二、线性数据结构</h2><h3 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组(Array)"></a>1. 数组(Array)</h3><h4 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1.特点"></a>1.1.特点</h4><ul><li>数组内元素具有相同的类型</li><li>每个元素对应一个唯一的索引，可以通过索引对数组内元素进行操作</li><li>数组大小在创建时固定，因而数组长度和元素个数可知</li><li>在内存中连续存储，可以进行高效的随机访问——通过索引直接访问</li><li></li></ul><h3 id="2-链表-Linked-List"><a href="#2-链表-Linked-List" class="headerlink" title="2. 链表(Linked List)"></a>2. 链表(Linked List)</h3><h3 id="3-栈-Stack"><a href="#3-栈-Stack" class="headerlink" title="3. 栈(Stack)"></a>3. 栈(Stack)</h3><p>用顺序表进行模拟：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elem<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> usedSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断栈是否满</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> usedSize <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//入栈</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//栈满则扩容</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elem <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elem<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>        usedSize<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断栈是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//出栈</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"栈为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> oldVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span>usedSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>usedSize<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"栈为空！"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elem<span class="token punctuation">[</span>usedSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="4-队列-Queue"><a href="#4-队列-Queue" class="headerlink" title="4. 队列(Queue)"></a>4. 队列(Queue)</h3><h3 id="5-线性-哈希表-Hash"><a href="#5-线性-哈希表-Hash" class="headerlink" title="5. (线性)哈希表(Hash)"></a>5. (线性)哈希表(Hash)</h3><h4 id="5-1-Hash概念引入"><a href="#5-1-Hash概念引入" class="headerlink" title="5.1.Hash概念引入"></a>5.1.Hash概念引入</h4><p>本质很简单，即通过一个函数，实现 键<strong>key</strong>和值<strong>value</strong>的映射,实现高效的元素查询.即向哈希表输入<strong>key</strong>,即可在$O(1)$ 时间内获取对应的<strong>value</strong>.</p><p>可联想: $学号 \xrightarrow[\text{Hash Function}]{\text{哈希函数}} 姓名$ </p><p>哈希表的增删查改四大基础操作时间复杂度均为$O(1)$ </p><h4 id="5-2-Hash的简单实现"><a href="#5-2-Hash的简单实现" class="headerlink" title="5.2.Hash的简单实现"></a>5.2.Hash的简单实现</h4><p>先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为「桶Bucket」，每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。</p><p>是通过 $「哈希函数 Hash Function」$ 实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <strong>key</strong> ，输出空间是所有桶（<em>index</em>）。换句话说，输入一个<strong>key</strong>，我们可以通过哈希函数得到该 <strong>key</strong> 对应的键值对在数组中的存储位置。</p><p>输入一个<strong>key</strong> ，哈希函数计算过程:</p><ol><li>通过某种哈希算法 hash() 计算得到哈希值。</li><li>将哈希值对桶数量（数组长度）<strong>capacity</strong> 取模，从而获取该 <strong>key</strong> 对应的数组索引 <strong>index</strong>。</li><li>$index &#x3D; hash(key) % capacity$</li></ol><img src="E:\DeskTable\博客学习截图传输\image-20231013000021119.png" alt="image-20231013000021119" style="zoom: 80%;" /><h4 id="5-3-哈希冲突"><a href="#5-3-哈希冲突" class="headerlink" title="5.3.哈希冲突"></a>5.3.哈希冲突</h4><p>本质上看，哈希函数的作用是将所有 key 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在<strong>多个输入对应相同输出</strong>的情况。而这种<strong>多对一</strong>的情况即被称为哈希冲突。</p><h4 id="5-3-1-链式地址法"><a href="#5-3-1-链式地址法" class="headerlink" title="5.3.1.链式地址法"></a>5.3.1.链式地址法</h4><p>为解决哈希冲突的第一种方法——「链式地址 Separate Chaining」，原理即是：单元格转换为链表，将生成的键值对当作链表节点，将所有发生冲突的键值对都存储在同一链表中。</p><ul><li>局限性:</li><li>空间开销较大</li><li>查询效果随着数据量的增大以及哈希冲突现象的出现频率的增多而逐渐降低,设想当有N个值对应同一个键时,此时在该节点上哈希表退化为了链表</li></ul><pre class=" language-c++"><code class="language-c++">class HashMapChaining&#123;private:    int size;                       // 键值对数量    int capacity;                   // 哈希表容量    double loadThres;               // 触发扩容的负载因子阈值    int extendRatio;                // 扩容倍数    vector<vector<Pair *>> buckets; // 桶数组public:    /* 构造方法 */    HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3), extendRatio(2)    &#123;        buckets.resize(capacity);    &#125;    /* 哈希函数 */    int hashFunc(int key)    &#123;        return key % capacity;    &#125;    /* 负载因子 */    double loadFactor()    &#123;        return (double)size / (double)capacity;    &#125;    /* 查询操作 */    string get(int key)    &#123;        int index = hashFunc(key);        // 遍历桶，若找到 key 则返回对应 val        for (Pair *pair : buckets[index])        &#123;            if (pair->key == key)            &#123;                return pair->val;            &#125;        &#125;        // 若未找到 key 则返回 nullptr        return nullptr;    &#125;    /* 添加操作 */    void put(int key, string val)    &#123;        // 当负载因子超过阈值时，执行扩容        if (loadFactor() > loadThres)        &#123;            extend();        &#125;        int index = hashFunc(key);        // 遍历桶，若遇到指定 key ，则更新对应 val 并返回        for (Pair *pair : buckets[index])        &#123;            if (pair->key == key)            &#123;                pair->val = val;                return;            &#125;        &#125;        // 若无该 key ，则将键值对添加至尾部        buckets[index].push_back(new Pair(key, val));        size++;    &#125;    /* 删除操作 */    void remove(int key)    &#123;        int index = hashFunc(key);        auto &bucket = buckets[index];        // 遍历桶，从中删除键值对        for (int i = 0; i < bucket.size(); i++)        &#123;            if (bucket[i]->key == key)            &#123;                Pair *tmp = bucket[i];                bucket.erase(bucket.begin() + i); // 从中删除键值对                delete tmp;                       // 释放内存                size--;                return;            &#125;        &#125;    &#125;    /* 扩容哈希表 */    void extend()    &#123;        // 暂存原哈希表        vector<vector<Pair *>> bucketsTmp = buckets;        // 初始化扩容后的新哈希表        capacity *= extendRatio;        buckets.clear();        buckets.resize(capacity);        size = 0;        // 将键值对从原哈希表搬运至新哈希表        for (auto &bucket : bucketsTmp)        &#123;            for (Pair *pair : bucket)            &#123;                put(pair->key, pair->val);            &#125;        &#125;    &#125;    /* 打印哈希表 */    void print()    &#123;        for (auto &bucket : buckets)        &#123;            cout << "[";            for (Pair *pair : bucket)            &#123;                cout << pair->key << " -> " << pair->val << ", ";            &#125;            cout << "]\n";        &#125;    &#125;&#125;;</code></pre><h4 id="5-3-2"><a href="#5-3-2" class="headerlink" title="5.3.2."></a>5.3.2.</h4><h2 id="三、非线性结构"><a href="#三、非线性结构" class="headerlink" title="三、非线性结构"></a>三、非线性结构</h2><h1 align = center > 树 </h1><h3 id="6-树（Tree）"><a href="#6-树（Tree）" class="headerlink" title="6. 树（Tree）"></a>6. 树（Tree）</h3><p>树（Tree）是一种常见的数据结构，它具有分层结构，类似于自然界中的树，由节点（Node）和边（Edge）组成。<code>每个树结构都包括一个根节点</code>，该节点没有父节点，而其他节点通过边与根节点和其他节点相连。</p><p>树可以被称为递归数据结构</p><p>树结构有许多不同的应用，包括计算机科学中的数据存储、搜索、排序以及层次性组织等。</p><h4 id="树结构中的常见的术语和特性"><a href="#树结构中的常见的术语和特性" class="headerlink" title="树结构中的常见的术语和特性"></a>树结构中的常见的术语和特性</h4><ol><li><strong>根节点（Root）</strong>：树结构的顶部节点，<strong>没有父节点</strong>，它是树的起始点。</li><li><strong>子节点（Child）</strong>：树中的每个节点可以有<strong>零个或多个</strong>子节点，子节点是其父节点的直接下级节点。</li><li><strong>父节点（Parent）</strong>：每个节点<strong>除了根节点</strong>外，都有一个父节点，它是其子节点的直接上级节点。</li><li><strong>叶子节点（Leaf）</strong>：<strong>没有子节点</strong>的节点称为叶子节点，它们位于树结构的末端 。</li><li><strong>兄弟节点（Sibling）</strong>：<strong>具有相同父节点</strong>的节点称为兄弟节点。</li><li><strong>节点的度</strong>：一个节点包含的子树的个数即为该节点的度</li><li><strong>树的度</strong>：所有节点的度当中的最大值</li><li><strong>节点的层次</strong>：根节点层次为1，以此递增</li><li><strong>深度（Depth）</strong>：从根节点到某个节点的路径上的边数称为该节点的深度。根节点的深度为0。</li><li><strong>高度（Height）</strong>：树结构中任意节点的最长路径（边数）称为树的高度。树的高度通常以根节点为参考。</li><li><strong>子树（Subtree）</strong>：树中的任何节点和其所有后代节点（包括该节点本身）构成的子树。</li><li><strong>有向边（Directed Edge）</strong>：连接两个节点的边<strong>具有方向</strong>，从一个节点指向另一个节点。</li></ol><h4 id="常见的树类型"><a href="#常见的树类型" class="headerlink" title="常见的树类型"></a>常见的树类型</h4><ol><li><p><strong>二叉树（Binary Tree）</strong>：每个节点最多有两个子节点，左子节点和右子节点。</p></li><li><p><strong>二叉搜索树（Binary Search Tree）</strong>：二叉树的一种，具有特定的排序规则，左子树的所有节点值小于根节点的值，右子树的所有节点值大于根节点的值。</p></li><li><p><strong>平衡二叉树（Balanced Binary Tree）</strong>：一种二叉搜索树，具有平衡性质，确保树的高度较低，提高了搜索等操作的效率。</p></li><li><p><strong>B树和B+树</strong>：用于在磁盘上高效存储和检索数据的树状数据结构，常见于数据库管理系统中。</p></li><li><p><strong>树堆（Heap）</strong>：一种特殊的树结构，用于高效查找和删除最大或最小值的元素，通常用于堆排序和优先队列。</p></li><li><p><strong>树结构的图形表示</strong>：树结构通常可以以树状图的方式进行可视化表示，根节点在顶部，子节点向下延伸。</p></li></ol><p>树结构是计算机科学中的重要数据结构之一，它们用于解决各种问题，包括数据存储、搜索、排序、编译器中的语法分析、操作系统中的文件系统等等。了解树结构的基本概念和特性对于编写高效的算法和解决问题非常重要。</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树中的许多操作的时间开销取决于树的高度，因此总希望二叉树的高度尽可能的小</p><h5 id="二叉树的三种遍历："><a href="#二叉树的三种遍历：" class="headerlink" title="二叉树的三种遍历："></a>二叉树的三种遍历：</h5><ul><li>前序遍历——先后访问根节点、左子树、右子树</li><li>中序遍历——先后访问左子树、根节点、右子树</li><li>后序遍历——先后访问左子树、右子树、根节点</li></ul><p>三序的遍历有更加直观易记的方法 <a href="https://www.bilibili.com/video/BV1Ub4y147Zv/?spm_id_from=333.337.search-card.all.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">无脑画点连线法，一学就会</a> 作者：<a href="https://space.bilibili.com/446171901">阿琛w</a></p><p>具体思路：</p><p>对于任意一颗树而言，前序遍历的形式总是<br>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是<br>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p><p>已知其中xx和xx序，推测第三种yy序：</p><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。</p><p>由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>细节</p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希映射（HashMap）来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p><p>————————————————<br>版权声明：本文为CSDN博主「看，未来」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43762191/article/details/107280503">种树：二叉树、二叉搜索树、AVL树、红黑树、哈夫曼树、B树、树与森林</a></p><p>————————————————</p><p>作者：LeetCode-Solution<br>原文链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">从前序与中序遍历序列构造二叉树</a></p><h4 id="完整二叉树（Complete-Binary-Tree）"><a href="#完整二叉树（Complete-Binary-Tree）" class="headerlink" title="完整二叉树（Complete Binary Tree）"></a>完整二叉树（Complete Binary Tree）</h4><p>完整二叉树（Complete Binary Tree）是一种二叉树，其中每一层都被完全填充，<strong>除了最后一层</strong>可能不是满的，但是最后一层的所有节点都<strong>集中在该层的左侧</strong>。</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol><li>所有叶子节点都出现在最后一层或倒数第二层。</li><li>如果有子节点，每个节点都有两个子节点。</li><li>最后一层的节点都尽可能地靠左排列。</li></ol><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><pre class=" language-html"><code class="language-html">      1    /   \   2     3  / \   / 4   5 6</code></pre><h4 id="完美二叉树（Perfect-Binary-Tree）"><a href="#完美二叉树（Perfect-Binary-Tree）" class="headerlink" title="完美二叉树（Perfect Binary Tree）"></a>完美二叉树（Perfect Binary Tree）</h4><p>完美二叉树（Perfect Binary Tree），也被称为满二叉树（Full Binary Tree），是一种特殊类型的二叉树</p><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ol><li>每个非叶子节点都有两个子节点。</li><li>所有叶子节点都在同一层级上，也就是说，树的<strong>所有层级都被完全填充</strong>。</li></ol><p>这意味着在完美二叉树中，每一层都包含最大数量的节点，即每一层的节点数都是2的幂次方。完美二叉树的高度（深度）通常由叶子节点的层级决定，如果有h层，则叶子节点位于第h层，树的高度为h。</p><h5 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h5><pre class=" language-html"><code class="language-html">        1      /   \     2     3    / \   / \   4   5 6   7</code></pre><h4 id="二叉搜索树（Binary-Search-Tree，BST）"><a href="#二叉搜索树（Binary-Search-Tree，BST）" class="headerlink" title="二叉搜索树（Binary Search Tree，BST）"></a>二叉搜索树（Binary Search Tree，BST）</h4><p>二叉搜索树（Binary Search Tree，BST）是一种二叉树的特殊形式。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>每个节点都包含一个值（通常是一个可比较的值），并且这些值按照特定的顺序排列。</li><li>对于每个节点：<ul><li>所有左子树中的节点的值都小于该节点的值。</li><li>所有右子树中的节点的值都大于该节点的值。</li><li>左右子树都是二叉搜索树。</li><li>每个节点的左右子树也是BST</li></ul></li><li>左子树的每一个节点的键值一定小于右子树每一个节点的键值（即右子树最小的键值）</li></ol><p>这个特性使得二叉搜索树非常适合进行快速的搜索、插入和删除操作，因为它充分利用了值的相对大小来构建树结构。如果树的结构是平衡的，搜索、插入和删除操作的时间复杂度通常为O(log n)，其中n是树中节点的数量。</p><h5 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h5><pre class=" language-html"><code class="language-html">        5       / \      3   8     / \ / \    1  4 7  9</code></pre><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p>需要注意的是，如果二叉搜索树的<strong>结构不平衡</strong>，即左子树和右子树的高度差异很大，搜索操作的性能可能会退化到O(n)，其中n是树中节点的数量。在极限情况下可能退化成链表（重新变成线性结构）</p><h5 id="BST常见操作："><a href="#BST常见操作：" class="headerlink" title="BST常见操作："></a>BST常见操作：</h5><h6 id="1、查找（搜索）："><a href="#1、查找（搜索）：" class="headerlink" title="1、查找（搜索）："></a>1、查找（搜索）：</h6><p>采取递归式搜索：</p><ol><li>value &lt; root，则向根节点左侧向下搜索</li><li>value &gt; root，则向根节点右侧向下搜索</li><li>当root为空或&#x3D;&#x3D;value时，直接返回为空或者返回根节点的值</li></ol><h6 id="2、插入："><a href="#2、插入：" class="headerlink" title="2、插入："></a>2、插入：</h6><p>新元素进入后，遇到大于的键值val的向左走，小于键值val的向右走，一直到尾端</p><h6 id="3、删除："><a href="#3、删除：" class="headerlink" title="3、删除："></a>3、删除：</h6><p>假设删除A节点</p><ol><li>A的度为0（叶节点）：直接移除A</li><li>A的度为1：A节点的节点直接补上</li><li>A的度为2：将A节点右子树键值最小的节点补上</li></ol><h4 id="线索二叉搜索树（）"><a href="#线索二叉搜索树（）" class="headerlink" title="线索二叉搜索树（）"></a>线索二叉搜索树（）</h4><p>在原来二叉树的基础上引入前驱和后继的概念，使得原来以树状逻辑排放的元素重新以线性逻辑排放。</p><p>存在一定问题，即某些节点的右节点即是其后继，或者其左节点即是其前驱</p><h4 id="平衡二叉树（Balanced-Binary-Tree）"><a href="#平衡二叉树（Balanced-Binary-Tree）" class="headerlink" title="平衡二叉树（Balanced Binary Tree）"></a>平衡二叉树（Balanced Binary Tree）</h4><p>平衡二叉树（Balanced Binary Tree），也称为平衡二叉搜索树（Balanced Binary Search Tree），是一种特殊类型的二叉搜索树（BST），因二叉搜索树的查找效率取决于树的高度，因而进一步提出而平衡二叉搜索树来保持树的高度达到最小。</p><h5 id="E-p："><a href="#E-p：" class="headerlink" title="E.p："></a>E.p：</h5><p>当输入序列 {1，2，3，4，5，6}，仍使用普通的二叉搜索树会退化成单链表：</p><p><img src="https://img-blog.csdnimg.cn/20200711144946466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img"></p><p>但使用平衡二叉搜索树则是：当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。这种左右子树的高度相差不超过1的树为平衡二叉树。</p><p><img src="https://img-blog.csdnimg.cn/20200711145115978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ol><li>每个节点都包含一个值（通常是可比较的值）。</li><li>对于每个节点：<ul><li>左子树和右子树的高度之差（平衡因子）最多为1。</li><li>左右子树都是平衡二叉树。</li></ul></li></ol><p>平衡二叉树的关键特性是它的高度相对较低，因此搜索、插入和删除操作的时间复杂度通常是O(log n)，其中n是树中节点的数量。</p><h5 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h5><pre class=" language-html"><code class="language-html">        4       / \      2   6     / \ / \    1  3 5  7</code></pre><h4 id="AVL树的构造："><a href="#AVL树的构造：" class="headerlink" title="AVL树的构造："></a>AVL树的构造：</h4><p>由上图可知：插入62节点之后，先进行普通的BST的插入，此时左子树高度为1，右子树高度为3，平衡因子的绝对值 &#x3D;&#x3D; 2，树失衡则需进行旋转操作：</p><h5 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h5><h5 id="左旋（LL平衡旋转）操作的步骤："><a href="#左旋（LL平衡旋转）操作的步骤：" class="headerlink" title="左旋（LL平衡旋转）操作的步骤："></a>左旋（LL平衡旋转）操作的步骤：</h5><ol><li>设定一个不平衡的节点为X，其右子树的高度比左子树高度高。</li><li>将X的右子节点Y取出，并将Y的左子节点B连接到X的右子节点。</li><li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点，以保持树的连接。</li><li>最后，将X连接到Y的左子节点B上。</li></ol><p>左旋操作后，X会变成Y的左子节点，而Y会成为X的父节点，从而保持了树的平衡性。</p><p>一直遍历，直到找到平衡因子的绝对值不为1的节点进行旋转操作。</p><p><strong>40</strong>的右节点<strong>51</strong>的左节点<strong>46</strong>接到<strong>40</strong>的右节点，而后将<strong>40</strong>这一节点接到<strong>51</strong>的左节点，如下图所示：</p><img src="https://img-blog.csdnimg.cn/2020071115165424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;" /><img src="https://img-blog.csdnimg.cn/20200711151718338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img" style="zoom:86%;" /><h5 id="右旋（RR平衡旋转）操作的步骤如下："><a href="#右旋（RR平衡旋转）操作的步骤如下：" class="headerlink" title="右旋（RR平衡旋转）操作的步骤如下："></a>右旋（RR平衡旋转）操作的步骤如下：</h5><ol><li>设定一个不平衡的节点为X，其左子树的高度比右子树高度高。</li><li>将X的左子节点Y取出，并将Y的右子节点B连接到X的左子节点。</li><li>然后，将X的父节点连接到Y，同时将Y的父节点设置为X的父节点。</li><li>最后，将X连接到Y的右子节点B上。</li></ol><p>右旋操作后，X会变成Y的右子节点，而Y会成为X的父节点，也能够保持树的平衡性。</p><p>A处的节点左右失衡，找到失衡节点的左节点B，将B的右节点E和B断开，接入A的左节点，而后将A接入到B的右节点。</p><p><img src="https://img-blog.csdnimg.cn/20200711154951407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200711155008636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzYyMTkx,size_16,color_FFFFFF,t_70" alt="img"></p><h5 id="双旋转（不平衡节点在内侧）"><a href="#双旋转（不平衡节点在内侧）" class="headerlink" title="双旋转（不平衡节点在内侧）"></a>双旋转（不平衡节点在内侧）</h5><h5 id="先左后右双旋转（LR平衡旋转）"><a href="#先左后右双旋转（LR平衡旋转）" class="headerlink" title="先左后右双旋转（LR平衡旋转）"></a>先左后右双旋转（LR平衡旋转）</h5><p>左孩子右子树上插入新的节点，导致的不平衡</p><p><img src="C:\Users\moru\AppData\Roaming\Typora\typora-user-images\image-20230918112359944.png" alt="image-20230918112359944"></p><h4 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h4><p><a href="https://zhuanlan.zhihu.com/p/348797577">深入理解伸展树(splay tree) - 知乎 (zhihu.com)</a></p><p>本质也是一颗二叉搜索树，但引入假设——当一个节点被访问时，该节点下一次被访问的可能性很大。基于该假设做出操作：每次一个节点被访问时，将该节点推到根节点的位置。</p><p>统计意义上的平衡树</p><p>这种结构可以不考虑进行树的平衡调整。</p><h5 id="单R-L型"><a href="#单R-L型" class="headerlink" title="单R&#x2F;L型"></a>单R&#x2F;L型</h5><p>根节点是查找节点的父节点。相当于直接将该节点提起，其他节点相对位置保持不变</p><img src="https://img-blog.csdn.net/20151102155743401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom: 67%;" /><img src="https://img-blog.csdn.net/20151102155639325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:73%;" /><h5 id="RR-LL型："><a href="#RR-LL型：" class="headerlink" title="RR&#x2F;LL型："></a>RR&#x2F;LL型：</h5><h5 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h5><p>单旋转</p><p>之字型</p><p>一字型</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（Binary Search Tree）。它是由Rudolf Bayer于1972年首次提出，后来由Leo J. Guibas和Robert Sedgewick进行改进。红黑树之所以重要，是因为它保持了二叉搜索树的基本性质，并在其上加入了一些额外的规则来确保树的高度保持在较小的范围内，从而保证了搜索、插入和删除操作的高效性。</p><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><ol><li>每个节点都有一个颜色，可以是红色或黑色。</li><li>根节点是黑色的。</li><li>所有叶子节点（NIL节点）都是黑色的。</li><li>叶节点是不存储数据的黑色空节点</li><li>如果一个节点是红色的，则其两个子节点必须是黑色的（不能有两个相连的红色节点）。</li><li>从任意节点到其每个叶子节点的路径都包含相同数量的黑色节点，这被称为黑色高度。</li></ol><p>这些性质确保了红黑树在插入和删除操作后能够自动调整自身，以保持平衡，从而避免出现最坏情况的性能。</p><p>红黑树广泛用于各种编程语言和数据结构中，包括C++的STL中的<code>std::map</code>和<code>std::set</code>，以及Java的<code>java.util.TreeMap</code>和<code>java.util.TreeSet</code>等。它们支持高效的搜索、插入和删除操作，并且在保持数据有序的同时，具有可预测的性能。</p><p>红黑树的操作复杂度为O(log n)，其中n是树中节点的数量。这使得它成为许多算法和数据结构的重要组成部分，特别是需要高效插入和删除操作的情况下。</p><h4 id="B-树（多-M路搜索树）"><a href="#B-树（多-M路搜索树）" class="headerlink" title="B-树（多&#x2F;M路搜索树）"></a>B-树（多&#x2F;M路搜索树）</h4><p><img src="E:\DeskTable\博客学习截图传输\image-20230922101648057.png" alt="image-20230922101648057"></p><p>（课本把终端节点当作叶子节点，所以“数据放在叶子节点”）</p><h5 id="B树提出的主要目的："><a href="#B树提出的主要目的：" class="headerlink" title="B树提出的主要目的："></a>B树提出的主要目的：</h5><p>减少磁盘I&#x2F;O操作。</p><p><strong>一颗m阶B树即是一颗平衡的m路搜索树</strong></p><p><strong>一颗B树的阶由叶子节点最多的分叉决定</strong></p><h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><p>B树可以视为将原本的二叉搜索树引入区间的概念，即将要每一个子节点根据键值进行区间的划分，从而通过比较待搜索的数和区间的关系进行查找。</p><ul><li><p>绝对平衡，因所有子树都在同一层</p></li><li><p>数据项存储在叶子节点上（即之前所有的节点均为索引或者说关键字&#x2F;键）</p></li><li><p>叶子节点的下一层（均为空节点）均为失败节点，出现在同一层，代表搜索失败的节点</p></li><li><p>非叶子节点存储直到</p></li><li><p>非根节点点至少有：$[m&#x2F;2]$(向上取整) 个子树，至多有$m$个子树</p></li><li><p>非根节点的关键字：</p><ul><li>有序（升序或者降序</li><li>最少有：$[M&#x2F;2]-1$(向上取整)；最多有：$M-1$(子节点数-1)</li></ul></li><li><p>根节点最少 1个关键字（二叉），最多M-1个关键字（M叉），即根节点儿子个数取值范围$[2,m]$</p></li></ul><h5 id="基础操作："><a href="#基础操作：" class="headerlink" title="基础操作："></a>基础操作：</h5><h5 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h5><p>与<strong>BST</strong>类似，由根节点出发，递归向下查找。</p><h4 id="B-树（M阶）："><a href="#B-树（M阶）：" class="headerlink" title="B+树（M阶）："></a>B+树（M阶）：</h4><p>基于B树提出，不同之处：</p><ol><li><p>非叶子节点子树指针个数与关键字个数相同</p></li><li><p>非叶子节点的子树指针P[i]-&gt;[K[i],K[i+1]]</p></li><li><p>所有叶子节点增加一个链指针，所有关键字都在叶子节点出现</p></li><li><p>B+树内部有两种节点，一种索引节点，一种叶子节点。</p></li><li><p>B+树索引——只用于索引，所有的数据保存</p></li></ol><h1 align = center> 哈希表 </h1><h3 id="7-非线性-哈希表"><a href="#7-非线性-哈希表" class="headerlink" title="7. (非线性)哈希表"></a>7. (非线性)哈希表</h3><p>哈希表，也叫散列表，一种由关键字到值并使用数组存储的数据结构</p><p>有一个hash function，关键字——hash function —— 值，将每个关键字映射到一个表当中。</p><p>理想当中，每一个关键字在经过hash function 后会有各自的值，但实际操作中，很可能不同的关键字得出相同的值，则会造成 <strong>hash冲突</strong>，因而会有以下几种解决冲突的方法。</p><p>1、分离链表法（separate chaining）：</p><p>将具有相同<strong>值</strong>的关键字存储到同一个 值链表 当中</p><p>2、开放地址法（Closed Hash Tbales&#x2F;Open Adderssing）</p><h3 id="8-堆"><a href="#8-堆" class="headerlink" title="8. 堆"></a>8. 堆</h3><p>1、二叉堆，简称堆：</p><p>堆是一颗完全填满的二叉树(叶子节点可以不填满，但是需要从左到右填充)，即一颗完全二叉树</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231008101022069.png" alt="image-20231008101022069"></p><h3 id="9-图"><a href="#9-图" class="headerlink" title="9. 图"></a>9. 图</h3><h2 id="四、搜索算法"><a href="#四、搜索算法" class="headerlink" title="四、搜索算法"></a>四、搜索算法</h2><h2 id="五、-排序算法"><a href="#五、-排序算法" class="headerlink" title="五、 排序算法"></a>五、 排序算法</h2><p>算法可视化网站:</p><p><a href="https://visualgo.net/en">通过动画可视化数据结构和算法 - VisuAlgo</a></p><p><a href="https://visualgo.net/zh/sorting">排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo</a> </p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p><h3 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言:"></a>10.1 引言:</h3><ol><li><p>「排序算法 Sorting Algorithm」用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有 序数据通常能够被更有效地查找、分析和处理。</p></li><li><p>在排序算法中，数据类型可以是整数、浮点数、字符或字符串等；顺序的判断规则可根据需求设定，如数字 大小、字符 ASCII 码顺序或自定义规则。</p></li></ol><h3 id="10-2-评价维度"><a href="#10-2-评价维度" class="headerlink" title="10.2 评价维度:"></a>10.2 评价维度:</h3><ol><li><p>运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（即时间复杂度中的常数项降低）。 对于大数据量情况，运行效率显得尤为重要。</p></li><li><p>就地性：顾名思义，「原地排序」通过在原数组上直接操作实现排序，无需借助额外的辅助数组，从而节省内 存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p></li><li><p>稳定性：「稳定排序」在完成排序后，相等元素在数组中的相对顺序不发生改变。稳定排序是优良特性，也是 多级排序场景的必要条件。</p><pre class=" language-html"><code class="language-html"># 输入数据是按照姓名排序好的# (name, age)('A', 19)('B', 18)('C', 21)('D', 19)('E', 23)# 假设使用非稳定排序算法按年龄排序列表，# 结果中 ('D', 19) 和 ('A', 19) 的相对位置改变，# 输入数据按姓名排序的性质丢失('B', 18)('D', 19)('A', 19)('C', 21)('E', 23)</code></pre></li><li><p>自适应性：「自适应排序」的时间复杂度会受输入数据的影响，即最佳、最差、平均时间复杂度并不完全相等。</p></li><li><p>是否基于比较：「基于比较的排序」依赖于比较运算符（&lt; , &#x3D; , &gt;）来判断元素的相对顺序，从而排序整个 数组，理论最优时间复杂度为 𝑂(𝑛 log 𝑛) 。而「非比较排序」不使用比较运算符，时间复杂度可达 𝑂(𝑛) ， 但其通用性相对较差。</p></li></ol><h3 id="10-3-理想排序算法"><a href="#10-3-理想排序算法" class="headerlink" title="10.3 理想排序算法"></a>10.3 理想排序算法</h3><p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。 接下来，罗列出各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。</p><h3 id="10-4-Theta-N-2-排序算法"><a href="#10-4-Theta-N-2-排序算法" class="headerlink" title="10.4 $\Theta(N^2)$ 排序算法"></a>10.4 $\Theta(N^2)$ 排序算法</h3><h4 id="10-4-1-冒泡排序"><a href="#10-4-1-冒泡排序" class="headerlink" title="10.4.1 冒泡排序"></a>10.4.1 冒泡排序</h4><h5 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h5><p>「冒泡排序 Bubble Sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样， 因此得名冒泡排序。</p><h5 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ol><li>首先，对 𝑛 个元素执行“冒泡”，将数组的最大元素交换至正确位置， </li><li>接下来，对剩余 𝑛 − 1 个元素执行“冒泡”，将第二大元素交换至正确位置。 </li><li>以此类推，经过 𝑛 − 1 轮“冒泡”后，前 𝑛 − 1 大的元素都被交换至正确位置。</li><li>仅剩的一个元素必定是最小元素，无需排序，因此数组排序完成。</li></ol><h5 id="3-算法特性"><a href="#3-算法特性" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li><strong>时间复杂度</strong>为 $O(n^2)$,<strong>自适应排序</strong>:各轮“冒泡”遍历的数组长度依次为$ 𝑛−1,𝑛−2, ⋯,2,1$,总和为 $\frac{n(n-1)}{2}$。在引入 flag 优化后，最佳时间复杂度可达到 $O(n)$ 。 </li><li>空间复杂度为 $O(1)$、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。 </li><li>稳定排序：由于在“冒泡”中遇到相等元素<strong>不交换</strong>。</li></ul><h5 id="4-伪代码"><a href="#4-伪代码" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html">do  swapped = false  for i = 1 to indexOfLastUnsortedElement-1:    if leftElement > rightElement:      swap(leftElement, rightElement)      swapped = true; ++swapCounterwhile swapped</code></pre><h5 id="5-c-代码实现"><a href="#5-c-代码实现" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><pre class=" language-c++"><code class="language-c++">template<typename T> //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(>)运算符void bubble_sort(T arr[], int len) &#123;    int i, j;    for (i = 0; i < len - 1; i++) &#123;        for (j = 0; j < len - 1 - i; j++) &#123;            if (arr[j] > arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="10-4-2-选择排序"><a href="#10-4-2-选择排序" class="headerlink" title="10.4.2 选择排序"></a>10.4.2 选择排序</h4><h5 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1. 原理"></a>1. 原理</h5><p> 「选择排序 Selection Sort」的工作原理非常直接：开启一个循环，每轮从未排序区间选择最小的元素，将其 放到已排序区间的末尾。</p><h5 id="2-算法步骤-1"><a href="#2-算法步骤-1" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h5 id="3-算法特性-1"><a href="#3-算法特性-1" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li>时间复杂度为 $𝑂(𝑛^2)$ 、非自适应排序：外循环共 $𝑛 − 1$ 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮 的未排序区间长度为 $2$ ，即各轮外循环分别包含 $𝑛 , 𝑛 − 1 , ⋯ , 2$ 轮内循环，求和为 $\frac{(𝑛−1)(𝑛+2)}{2}$ 。</li><li>空间复杂度 $𝑂(1)$ 、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。</li><li>非稳定排序：在交换元素时，有可能将 $nums[i]$ 交换至其相等元素的右边，导致两者的相对顺序发生改变。</li></ul><h5 id="4-伪代码-1"><a href="#4-伪代码-1" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html">重复（元素个数-1）次  把第一个没有排序过的元素设置为最小值  遍历每个没有排序过的元素    如果元素 &lt; 现在的最小值      将此元素设置成为新的最小值  将最小值和第一个没有排序过的位置交换</code></pre><h5 id="5-c-代码实现-1"><a href="#5-c-代码实现-1" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><pre class=" language-c++"><code class="language-c++">template<class T> //整數或浮點數皆可使用，若要使用物件（class）時必須重载运算符(>)void selection_sort(std::vector<T>& arr) &#123;    for (int i = 0; i < arr.size() - 1; i++) &#123;        int min = i;        for (int j = i + 1; j < arr.size(); j++) &#123;            if (arr[j] < arr[min]) &#123;                min = j;            &#125;        &#125;        std::swap(arr[i], arr[min]);    &#125;&#125;</code></pre><h4 id="10-4-3-插入排序"><a href="#10-4-3-插入排序" class="headerlink" title="10.4.3 插入排序"></a>10.4.3 插入排序</h4><h5 id="1-原理-2"><a href="#1-原理-2" class="headerlink" title="1. 原理"></a>1. 原理</h5><p>「插入排序 Insertion Sort」是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p><h5 id="2-算法步骤-2"><a href="#2-算法步骤-2" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ol><li>初始状态下，数组的第 1 个元素已完成排序。</li><li>选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。</li><li>选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。</li><li>以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。</li></ol><h5 id="3-算法特性-2"><a href="#3-算法特性-2" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li>时间复杂度 $𝑂(𝑛^2 )$ 、自适应排序：最差情况下，每次插入操作分别需要循环 $𝑛 − 1 , 𝑛 − 2 , ⋯ , 2 , 1$ 次，求和得到 $\frac{(𝑛−1)𝑛}{2}$ ，因此时间复杂度为 $𝑂(𝑛^2 )$ 。在遇到有序数据时，插入操作会提前终止。当输入 数组完全有序时，插入排序达到最佳时间复杂度 $𝑂(𝑛)$ 。</li><li>空间复杂度 $𝑂(1)$ 、原地排序：指针 𝑖 , 𝑗 使用常数大小的额外空间。</li><li>稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li></ul><h5 id="4-伪代码-2"><a href="#4-伪代码-2" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html">将第一个元素标记为已排序对于每一个未排序的元素 X  “提取” 元素 X  i = 最后排序过元素的索引 到 0 的遍历    如果当前元素 j > X      将排序过的元素向右移一格    跳出循环并在此插入 X</code></pre><h5 id="5-c-代码实现-2"><a href="#5-c-代码实现-2" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><pre class=" language-c++"><code class="language-c++">void insertion_sort(int arr[], int len) &#123;    for (int i = 1; i < len; i++) &#123;        int key = arr[i];        int j = i - 1;        while ((j >= 0) && (key < arr[j])) &#123;            arr[j + 1] = arr[j];            j--;        &#125;        arr[j + 1] = key;    &#125;&#125;</code></pre><h3 id="10-5-Theta-N-logN-排序算法"><a href="#10-5-Theta-N-logN-排序算法" class="headerlink" title="10.5 $\Theta(N logN)$ 排序算法"></a>10.5 $\Theta(N logN)$ 排序算法</h3><h4 id="10-5-1-希尔排序"><a href="#10-5-1-希尔排序" class="headerlink" title="10.5.1 希尔排序"></a>10.5.1 希尔排序</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本(插入排序plus版)<br>基于插入排序两种性质提出的改进:</p><ul><li>插入排序在对<strong>近似良序</strong>的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><h5 id="1-原理-3"><a href="#1-原理-3" class="headerlink" title="1. 原理"></a>1. 原理</h5><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h5 id="2-算法步骤-3"><a href="#2-算法步骤-3" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ul><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h5 id="3-算法特性-3"><a href="#3-算法特性-3" class="headerlink" title="3.算法特性"></a>3.算法特性</h5><ul><li>时间复杂度为:</li><li>空间复杂度为:</li><li>采取分治思想,将数组通过增量序列分解后得出各部分的局部最优解,再进行归整得到全局最优解。</li></ul><h5 id="4-伪代码-3"><a href="#4-伪代码-3" class="headerlink" title="4.伪代码"></a>4.伪代码</h5><pre class=" language-html"><code class="language-html"></code></pre><h5 id="5-c-代码实现-3"><a href="#5-c-代码实现-3" class="headerlink" title="5.c++代码实现"></a>5.c++代码实现</h5><pre class=" language-c++"><code class="language-c++">template<class T>void shell_sort(T array[], int length) &#123;    int h = 1;    while (h < length / 3) &#123;        h = 3 * h + 1;    &#125;    while (h >= 1) &#123;        for (int i = h; i < length; i++) &#123;            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) &#123;                std::swap(array[j], array[j - h]);            &#125;        &#125;        h = h / 3;    &#125;&#125;</code></pre><h4 id="10-5-2-归并排序"><a href="#10-5-2-归并排序" class="headerlink" title="10.5.2 归并排序"></a>10.5.2 归并排序</h4><h5 id="1-原理-4"><a href="#1-原理-4" class="headerlink" title="1. 原理"></a>1. 原理</h5><p>该算法原理是是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><h5 id="2-算法步骤-4"><a href="#2-算法步骤-4" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ul><li>“划分阶段”从顶至底递归地将数组从中点切为两个子数组：<ol><li>计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）。 </li><li>递归执行步骤 1. ，直至子数组区间长度为 1 时，终止递归划分。</li></ol></li><li>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开 始合并，合并阶段中的每个子数组都是有序的。</li></ul><p>图示参见连接:</p><p><a href="https://www.runoob.com/w3cnote/merge-sort.html">1.5 归并排序 | 菜鸟教程 (runoob.com)</a> </p><h5 id="3-算法特性-4"><a href="#3-算法特性-4" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li>时间复杂度 $𝑂(𝑛 log 𝑛)$ 、非自适应排序：划分产生高度为 $log 𝑛 $的递归树，每层合并的总操作数量为$ 𝑛$ ，因此总体时间复杂度为 $𝑂(𝑛 log 𝑛)$ 。</li><li>空间复杂度 $ 𝑂(𝑛)$ 、非原地排序：递归深度为 $ log 𝑛$ ，使用 $𝑂(log 𝑛) $大小的栈帧空间。合并操作需要 借助辅助数组实现，使用 $𝑂(𝑛)$ 大小的额外空间。</li><li>稳定排序：在合并过程中，相等元素的次序保持不变。</li></ul><h5 id="4-伪代码-4"><a href="#4-伪代码-4" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html">将每个元素拆分成大小为1的分区递归地合并相邻的分区  遍历 i = 左侧首项位置 到 右侧末项位置    如果左侧首项的值 &lt;= 右侧首项的值      拷贝左侧首项的值    否则： 拷贝右侧首项的值; 增加逆序数将元素拷贝进原来的数组中</code></pre><h5 id="5-c-代码实现-4"><a href="#5-c-代码实现-4" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><ol><li>迭代版</li></ol><pre class=" language-c++"><code class="language-c++">template<class T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(<)的運算子功能void merge_sort(T arr[], int len) &#123;    T* a = arr;    T* b = new T[len];    for (int seg = 1; seg < len; seg += seg) &#123;        for (int start = 0; start < len; start += seg + seg) &#123;            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);            int k = low;            int start1 = low, end1 = mid;            int start2 = mid, end2 = high;            while (start1 < end1 && start2 < end2) &#123;                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];            &#125;            while (start1 < end1) &#123;                b[k++] = a[start1++];            &#125;            while (start2 < end2) &#123;                b[k++] = a[start2++];            &#125;        &#125;        T* temp = a;        a = b;        b = temp;    &#125;    if (a != arr) &#123;        for (int i = 0; i < len; i++) &#123;            b[i] = a[i];        &#125;        b = a;    &#125;    delete[] b;&#125;</code></pre><ol start="2"><li>递归版</li></ol><pre class=" language-c++"><code class="language-c++">void Merge(vector<int>& Array, int front, int mid, int end) &#123;    // preconditions:    // Array[front...mid] is sorted    // Array[mid+1 ... end] is sorted    // Copy Array[front ... mid] to LeftSubArray    // Copy Array[mid+1 ... end] to RightSubArray    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);    int idxLeft = 0, idxRight = 0;    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]    for (int i = front; i <= end; i++) &#123;        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) &#123;            Array[i] = LeftSubArray[idxLeft];            idxLeft++;        &#125;        else &#123;            Array[i] = RightSubArray[idxRight];            idxRight++;        &#125;    &#125;&#125;void MergeSort(vector<int>& Array, int front, int end) &#123;    if (front >= end) &#123;        return;    &#125;    int mid = (front + end) / 2;    MergeSort(Array, front, mid);    MergeSort(Array, mid + 1, end);    Merge(Array, front, mid, end);&#125;</code></pre><h4 id="10-5-3-快速排序"><a href="#10-5-3-快速排序" class="headerlink" title="10.5.3 快速排序"></a>10.5.3 快速排序</h4><h5 id="1-原理-5"><a href="#1-原理-5" class="headerlink" title="1. 原理"></a>1. 原理</h5><ol><li><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p></li><li><p>体现出的核心操作「哨兵划分」：选取序列当中的某一个元素作为”基准数“，将所有小于该基准数的元素移到左侧，反之移到右侧。</p><ul><li>选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。</li><li>设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ul></li><li><p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组；</p></li></ol><p>  并且满足“$左子数组任意元素≤基准数≤右子数组任意元素$”。</p><p>  因此，接下来只需对这两个子数组进行排序。</p><ol start="4"><li>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</li></ol><h5 id="2-算法步骤-5"><a href="#2-算法步骤-5" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ul><li><p>首先，对原数组执行一次「哨兵划分」，得到未排序的左子数组和右子数组。</p></li><li><p>然后，对左子数组和右子数组分别递归执行「哨兵划分」。</p></li><li><p>然后，对左子数组和右子数组分别递归执行「哨兵划分」。</p></li></ul><h5 id="3-算法特性-5"><a href="#3-算法特性-5" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li><p>顾名思义，简单粗暴，就是快，效率高，处理大量数据最快的排序算法之一。</p></li><li><p>时间复杂度 $𝑂(𝑛 log 𝑛)$ 、自适应排序：在平均情况下，哨兵划分的递归层数为 $log 𝑛$ ，每层中的总循环数为 𝑛 ，总体使用 $𝑂(𝑛 log 𝑛)$ 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为 长度为 0 和 $𝑛 − 1$ 的两个子数组，此时递归层数达到 𝑛 层，每层中的循环数为 𝑛 ，总体使用 $ 𝑂(𝑛2 )$ 时间。</p></li><li><p>空间复杂度 $𝑂(𝑛)$ 、原地排序：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 $𝑂(𝑛)$ 栈 帧空间。排序操作是在原数组上进行的，未借助额外数组。 </p></li><li><p>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</p></li></ul><pre class=" language-html"><code class="language-html">快排为什么快:1、出现最差情况的概率很低：虽然快速排序的最差时间复杂度为 𝑂(𝑛2) ，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛 log 𝑛) 的时间复杂度下运行。2、缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像「堆排序」这类算法需要跳跃式访问元素，从而缺乏这一特性。3、复杂度的常数系数低：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与「插入排序」比「冒泡排序」更快的原因类似。快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平均期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序  ——《算法艺术与信息学竞赛》</code></pre><h5 id="4-伪代码-5"><a href="#4-伪代码-5" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html">每个（未排序）的部分将第一个元素设为 pivot  存储索引 = pivot索引 +1  从 i=pivot指数 +1 到 最右索引 的遍历    如果 a[i] &lt; a[pivot]      交换 (i, 存储索引); 存储索引++;  交换(pivot, 存储索引 - 1)</code></pre><h5 id="5-c-代码实现："><a href="#5-c-代码实现：" class="headerlink" title="5. c++代码实现："></a>5. c++代码实现：</h5><pre class=" language-c++"><code class="language-c++">//严蔚敏《数据结构》标准分割函数 int Paritition1(int A[], int low, int high) &#123;   int pivot = A[low];   while (low < high) &#123;     while (low < high && A[high] >= pivot) &#123;       --high;     &#125;     A[low] = A[high];     while (low < high && A[low] <= pivot) &#123;       ++low;     &#125;     A[high] = A[low];   &#125;   A[low] = pivot;   return low; &#125; void QuickSort(int A[], int low, int high) //快排母函数 &#123;   if (low < high) &#123;     int pivot = Paritition1(A, low, high);     QuickSort(A, low, pivot - 1);     QuickSort(A, pivot + 1, high);   &#125; &#125;</code></pre><h4 id="10-5-4-堆排序"><a href="#10-5-4-堆排序" class="headerlink" title="10.5.4 堆排序"></a>10.5.4 堆排序</h4><h5 id="1-原理-6"><a href="#1-原理-6" class="headerlink" title="1. 原理"></a>1. 原理</h5><ol><li><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul></li></ol><h5 id="2-算法步骤-6"><a href="#2-算法步骤-6" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ol><li>创建一个堆 H[0……n-1]，建立大顶堆。完成后，最大元素位于堆顶；</li><li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元 素数量加 1 ；</li><li>从堆顶元素开始，从顶到底执行堆化操作（Sift Down），完成堆化后，堆的性质得到修复；</li><li>循环执行第 2. 和 3. 步。循环 𝑛 − 1 轮后，即可完成数组排序。</li></ol><h5 id="3-算法特性-6"><a href="#3-算法特性-6" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li>时间复杂度 $𝑂(𝑛 log 𝑛)$ 、非自适应排序：建堆操作使用 $𝑂(𝑛)$ 时间。从堆中提取最大元素的时间复杂 度为 $𝑂(log 𝑛)$ ，共循环 𝑛 − 1 轮。</li><li>空间复杂度 $𝑂(1)$ 、原地排序：几个指针变量使用 $𝑂(1)$ 空间。元素交换和堆化操作都是在原数组上进 行的。</li><li>非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li></ul><h5 id="4-伪代码-6"><a href="#4-伪代码-6" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre><code></code></pre><h5 id="5-c-代码实现-5"><a href="#5-c-代码实现-5" class="headerlink" title="5.c++代码实现"></a>5.c++代码实现</h5><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <algorithm>using namespace std;void max_heapify(int arr[], int start, int end) &#123;    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son <= end) &#123; // 若子節點指標在範圍內才做比較        if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] > arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else &#123; // 否則交換父子內容再繼續子節點和孫節點比較            swap(arr[dad], arr[son]);            dad = son;            son = dad * 2 + 1;        &#125;    &#125;&#125;void heap_sort(int arr[], int len) &#123;    // 初始化，i從最後一個父節點開始調整    for (int i = len / 2 - 1; i >= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢    for (int i = len - 1; i > 0; i--) &#123;        swap(arr[0], arr[i]);        max_heapify(arr, 0, i - 1);    &#125;&#125;int main() &#123;    int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    for (int i = 0; i < len; i++)        cout << arr[i] << ' ';    cout << endl;    return 0;&#125;</code></pre><h3 id="10-6-Theta-N-K-排序算法"><a href="#10-6-Theta-N-K-排序算法" class="headerlink" title="10.6 $\Theta(N+K)$ 排序算法"></a>10.6 $\Theta(N+K)$ 排序算法</h3><h4 id="10-6-1-计数排序"><a href="#10-6-1-计数排序" class="headerlink" title="10.6.1 计数排序"></a>10.6.1 计数排序</h4><h5 id="1-原理-7"><a href="#1-原理-7" class="headerlink" title="1. 原理"></a>1. 原理</h5><ol><li>个人理解就是一个哈希表</li><li>「计数排序 Counting Sort」通过统计元素数量来实现排序，通常应用于整数数组。</li><li>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</li></ol><h5 id="2-算法步骤-7"><a href="#2-算法步骤-7" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><ol><li>遍历数组，找出数组中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚 + 1 的辅助数组 counter 。</li><li>借助 counter 统计 nums 中各数字的出现次数，其中 counter[num] 对应数字 num 的出现次数。统计方法 很简单，只需遍历 nums（设当前数字为 num），每轮将 counter[num] 增加 1 即可。</li><li>由于 counter 的各个索引天然有序，因此相当于所有数字已经被排序好了。接下来，我们遍历 counter ，根据各数字的出现次数，将它们按从小到大的顺序填入 nums 即可。</li></ol><h5 id="3-算法特性-7"><a href="#3-算法特性-7" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li>当输入的元素是n个0到k之间的整数时，它的运行时间是 $Θ(n + k)$计数排序不是比较排序，排序的速度快于任何比较排序算法。</li><li>时间复杂度 𝑂(𝑛 + 𝑚) ：涉及遍历 $nums$ 和遍历 $counter$ ，都使用线性时间。一般情况下 $𝑛 ≫ 𝑚$ ，时 间复杂度趋于 $𝑂(𝑛)$ 。</li><li>空间复杂度 $𝑂(𝑛 + 𝑚)$ 、非原地排序：借助了长度分别为 𝑛 和 𝑚 的数组 $res$ 和 $counter$ 。</li><li>稳定排序：由于向 $res$ 中填充元素的顺序是“从右向左”的，因此倒序遍历 $nums$ 可以避免改变相等元 素之间的相对位置，从而实现稳定排序。实际上，正序遍历 $nums$ 也可以得到正确的排序结果，但结果 是非稳定的。</li></ul><h5 id="4-伪代码-7"><a href="#4-伪代码-7" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html">创建关键值（计数）数组遍历数列中的每个元素相应的计数器增加 1每轮计数，都从最小的值开始当计数为非零数时重新将元素存储于列表将计数减1</code></pre><h5 id="5-c代码实现"><a href="#5-c代码实现" class="headerlink" title="5. c代码实现"></a>5. c代码实现</h5><pre class=" language-c++"><code class="language-c++">#include <stdio.h>#include <stdlib.h>#include <time.h>void print_arr(int *arr, int n) &#123;        int i;        printf("%d", arr[0]);        for (i = 1; i < n; i++)                printf(" %d", arr[i]);        printf("\n");&#125;void counting_sort(int *ini_arr, int *sorted_arr, int n) &#123;        int *count_arr = (int *) malloc(sizeof(int) * 100);        int i, j, k;        for (k = 0; k < 100; k++)                count_arr[k] = 0;        for (i = 0; i < n; i++)                count_arr[ini_arr[i]]++;        for (k = 1; k < 100; k++)                count_arr[k] += count_arr[k - 1];        for (j = n; j > 0; j--)                sorted_arr[--count_arr[ini_arr[j - 1]]] = ini_arr[j - 1];        free(count_arr);&#125;int main(int argc, char **argv) &#123;        int n = 10;        int i;        int *arr = (int *) malloc(sizeof(int) * n);        int *sorted_arr = (int *) malloc(sizeof(int) * n);        srand(time(0));        for (i = 0; i < n; i++)                arr[i] = rand() % 100;        printf("ini_array: ");        print_arr(arr, n);        counting_sort(arr, sorted_arr, n);        printf("sorted_array: ");        print_arr(sorted_arr, n);        free(arr);        free(sorted_arr);        return 0;&#125;</code></pre><h4 id="10-6-2-桶排序"><a href="#10-6-2-桶排序" class="headerlink" title="10.6.2 桶排序"></a>10.6.2 桶排序</h4><h5 id="1-原理-8"><a href="#1-原理-8" class="headerlink" title="1. 原理"></a>1. 原理</h5><ol><li>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：<ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol></li><li>「桶排序 Bucket Sort」是分治思想的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</li></ol><h5 id="2-算法步骤-8"><a href="#2-算法步骤-8" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><p>考虑一个长度为 𝑛 的数组，元素是范围 [0, 1) 的浮点数。桶排序的流程如下： </p><ol><li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。 </li><li>对每个桶分别执行排序（本文采用编程语言的内置排序函数）。 </li><li>按照桶的从小到大的顺序，合并结果。</li></ol><h5 id="3-算法特性-8"><a href="#3-算法特性-8" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><ul><li>时间复杂度 $𝑂(𝑛 + 𝑘)$ ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 $\frac{𝑛}{𝑘}$ 。假设排序单 个桶使用 $𝑂( \frac{𝑛}{𝑘} log(\frac{𝑛}{𝑘}))$ 时间，则排序所有桶使用 $𝑂(𝑛log(\frac{𝑛}{𝑘}))$ 时间。当<strong>桶数量 𝑘 比较大时，时间复杂度则趋向于</strong> $𝑂(𝑛) $。合并结果时需要遍历所有桶和元素，花费 $𝑂(𝑛 + 𝑘) $时间。</li><li>自适应排序：在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用 $𝑂(𝑛^2 ) $时间。</li><li>空间复杂度 $𝑂(𝑛 + 𝑘)$ 、非原地排序：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li></ul><h5 id="4-伪代码-8"><a href="#4-伪代码-8" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html"></code></pre><h5 id="5-c-代码实现-6"><a href="#5-c-代码实现-6" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><pre class=" language-c++"><code class="language-c++">#include<iterator>#include<iostream>#include<vector>using namespace std;const int BUCKET_NUM = 10;struct ListNode&#123;        explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125;        ListNode* mNext;        int mData;&#125;;ListNode* insert(ListNode* head,int val)&#123;        ListNode dummyNode;        ListNode *newNode = new ListNode(val);        ListNode *pre,*curr;        dummyNode.mNext = head;        pre = &dummyNode;        curr = head;        while(NULL!=curr && curr->mData<=val)&#123;                pre = curr;                curr = curr->mNext;        &#125;        newNode->mNext = curr;        pre->mNext = newNode;        return dummyNode.mNext;&#125;ListNode* Merge(ListNode *head1,ListNode *head2)&#123;        ListNode dummyNode;        ListNode *dummy = &dummyNode;        while(NULL!=head1 && NULL!=head2)&#123;                if(head1->mData <= head2->mData)&#123;                        dummy->mNext = head1;                        head1 = head1->mNext;                &#125;else&#123;                        dummy->mNext = head2;                        head2 = head2->mNext;                &#125;                dummy = dummy->mNext;        &#125;        if(NULL!=head1) dummy->mNext = head1;        if(NULL!=head2) dummy->mNext = head2;                return dummyNode.mNext;&#125;void BucketSort(int n,int arr[])&#123;        vector<ListNode*> buckets(BUCKET_NUM,(ListNode*)(0));        for(int i=0;i<n;++i)&#123;                int index = arr[i]/BUCKET_NUM;                ListNode *head = buckets.at(index);                buckets.at(index) = insert(head,arr[i]);        &#125;        ListNode *head = buckets.at(0);        for(int i=1;i<BUCKET_NUM;++i)&#123;                head = Merge(head,buckets.at(i));        &#125;        for(int i=0;i<n;++i)&#123;                arr[i] = head->mData;                head = head->mNext;        &#125;&#125;</code></pre><h3 id="10-7-Theta-N-times-K-排序算法"><a href="#10-7-Theta-N-times-K-排序算法" class="headerlink" title="10.7 $\Theta(N \times K)$ 排序算法"></a>10.7 $\Theta(N \times K)$ 排序算法</h3><h4 id="10-7-1-基数排序"><a href="#10-7-1-基数排序" class="headerlink" title="10.7.1 基数排序"></a>10.7.1 基数排序</h4><h5 id="1-原理-9"><a href="#1-原理-9" class="headerlink" title="1. 原理"></a>1. 原理</h5><ol><li>两次哈希表的应用，将一个数拆分成基数形式表示，通过基数进行分配比较</li><li>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</li><li>「基数排序 Radix Sort」的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</li></ol><h5 id="2-算法步骤-9"><a href="#2-算法步骤-9" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h5><p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的步骤如下： </p><ol><li>初始化位数 𝑘 &#x3D; 1 。 </li><li>对学号的第 𝑘 位执行「计数排序」。完成后，数据会根据第 𝑘 位从小到大排序。 </li><li>将 𝑘 增加 1 ，然后返回步骤 2. 继续迭代，直到所有位都排序完成后结束。</li></ol><h5 id="3-算法特性-9"><a href="#3-算法特性-9" class="headerlink" title="3. 算法特性"></a>3. 算法特性</h5><p>相较于计数排序，基数排序适用于数值范围较大的情况，但前提是数据必须可以表示为固定位数的格式，且位 数不能过大。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 $𝑂(𝑛𝑘) ≫ 𝑂(𝑛2 )$ 。 </p><ul><li>时间复杂度 𝑂(𝑛𝑘) ：设数据量为 𝑛 、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 $𝑂(𝑛 + 𝑑)$ 时间，排序所有 𝑘 位使用 $𝑂((𝑛 + 𝑑)𝑘)$ 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 $𝑂(𝑛)$ 。 </li><li>空间复杂度 $𝑂(𝑛 + 𝑑)$ 、非原地排序：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 $res$ 和 $counter$ 。</li><li>稳定排序：与计数排序相同。</li></ul><h5 id="4-伪代码-9"><a href="#4-伪代码-9" class="headerlink" title="4. 伪代码"></a>4. 伪代码</h5><pre class=" language-html"><code class="language-html">分别给每个数位（0到9）创造1个桶（数列），共计10个遍历每个数位遍历数列中的每个元素将元素移至相应的桶中在每个桶中，从最小的数位开始当桶不是空的将元素恢复至数列中</code></pre><h5 id="5-c-代码实现-7"><a href="#5-c-代码实现-7" class="headerlink" title="5. c++代码实现"></a>5. c++代码实现</h5><pre class=" language-c++"><code class="language-c++">int maxbit(int data[], int n) //辅助函数，求数据的最大位数&#123;    int maxData = data[0];              ///< 最大数    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。    for (int i = 1; i < n; ++i)    &#123;        if (maxData < data[i])            maxData = data[i];    &#125;    int d = 1;    int p = 10;    while (maxData >= p)    &#123;        //p *= 10; // Maybe overflow        maxData /= 10;        ++d;    &#125;    return d;/*    int d = 1; //保存最大的位数    int p = 10;    for(int i = 0; i < n; ++i)    &#123;        while(data[i] >= p)        &#123;            p *= 10;            ++d;        &#125;    &#125;    return d;*/&#125;void radixsort(int data[], int n) //基数排序&#123;    int d = maxbit(data, n);    int *tmp = new int[n];    int *count = new int[10]; //计数器    int i, j, k;    int radix = 1;    for(i = 1; i <= d; i++) //进行d次排序    &#123;        for(j = 0; j < 10; j++)            count[j] = 0; //每次分配前清空计数器        for(j = 0; j < n; j++)        &#123;            k = (data[j] / radix) % 10; //统计每个桶中的记录数            count[k]++;        &#125;        for(j = 1; j < 10; j++)            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中        &#123;            k = (data[j] / radix) % 10;            tmp[count[k] - 1] = data[j];            count[k]--;        &#125;        for(j = 0; j < n; j++) //将临时数组的内容复制到data中            data[j] = tmp[j];        radix = radix * 10;    &#125;    delete []tmp;    delete []count;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的计组</title>
      <link href="/2023/09/15/cong-ling-kai-shi-de-ji-suan-ji-zu-cheng-yuan-li/"/>
      <url>/2023/09/15/cong-ling-kai-shi-de-ji-suan-ji-zu-cheng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 align =center > 计算机组成原理 </h1><h1 id="Chapter9-Arithmetic"><a href="#Chapter9-Arithmetic" class="headerlink" title="Chapter9 Arithmetic"></a>Chapter9 Arithmetic</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li><p>数据本身毫无意义，但可以用来在统一观念下进行特定的解释，创造出抽象的概念，赋予其特定场景下的含义。</p></li><li><p>硬件实现的数据类型——数据表示</p></li><li><p>软件实现的数据类型——数据结构</p></li></ul><h2 id="数的表示："><a href="#数的表示：" class="headerlink" title="数的表示："></a>数的表示：</h2><h3 id="1、整数"><a href="#1、整数" class="headerlink" title="1、整数"></a>1、整数</h3><ul><li><p>原码</p></li><li><p>反码</p></li><li><p>补码</p></li></ul><p>首位为“0”——正数；首位为“1”——负数</p><p>正数的三种码都一样，负数才有区别</p><h2 id="BCD码（Binary-Coded-Decimal）"><a href="#BCD码（Binary-Coded-Decimal）" class="headerlink" title="BCD码（Binary-Coded Decimal）"></a>BCD码（Binary-Coded Decimal）</h2><h3 id="8421码（有权码）最常见："><a href="#8421码（有权码）最常见：" class="headerlink" title="8421码（有权码）最常见："></a>8421码（有权码）最常见：</h3><p>采取 4个二进制位对应一个十进制位</p><p>每一位的权重分别为：8、4、2、1</p><p>计算方法：</p><p>E.p ：5（0101）+ 8（1000） &#x3D; 13（1101）不在映射内（1010~1 0010）则加上6进行修正</p><p>则13（1101）+ 6（0110） &#x3D; 19（1 0011）&#x3D;&#x3D; 1（00001）&amp;&amp; 3（0011）</p><h3 id="2421码："><a href="#2421码：" class="headerlink" title="2421码："></a>2421码：</h3><p>重定义的权值</p><img src="E:\DeskTable\博客学习截图传输\image-20230919163128770.png" alt="image-20230919163128770" style="zoom:50%;" /><h3 id="其他的4位有权BCD码："><a href="#其他的4位有权BCD码：" class="headerlink" title="其他的4位有权BCD码："></a>其他的4位有权BCD码：</h3><p>5421码、5211码、4311码 —— 这三种对9互补，逢十进一</p><p>84-2-1（八四负二负一）码</p><h3 id="余3码（无权码）："><a href="#余3码（无权码）：" class="headerlink" title="余3码（无权码）："></a>余3码（无权码）：</h3><p>$8421码 + (0011)_2$</p><h3 id="其他的4位无权BCD码："><a href="#其他的4位无权BCD码：" class="headerlink" title="其他的4位无权BCD码："></a>其他的4位无权BCD码：</h3><p>格雷码（1）、格雷码（2）、格雷码（3）</p><h2 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h2><p><strong>原码</strong>：</p><p>特点：</p><ul><li>含有+0和-0</li><li>计算乘除法比较方便，加减法较麻烦</li></ul><p>为了简便加减法运算，设计出了<strong>补码</strong></p><p><strong>补码</strong>：</p><ul><li>无模运算：实数范围内进行运算</li><li>有模运算：<ol><li>概念：给定一个正整数p，任意一个整数n，一定存在等式 n &#x3D; k*p + r<br>其中k 、r 是整数，且 0 ≤ r &lt; p 称呼k 为n 除以p 的商，r 为n 除以p的余数。</li><li>有模运算体系当中，减去一个数等于加上这个数对模的补数。如a+b&#x3D;M a和b互为补数</li></ol></li><li>（二进制）正数的补码是其本身，负数（无论整数还是小数 ）的补码，将负数变成补码——每一位取反末位加一</li></ul><p>在计算机当中，加减法均采用补码进行</p><ul><li><p>在纯小数二进制编码当中 补码为1.0000000 —&gt;真值：-1.0000000 最高位表示为数值位也是符号位；原码：超出范围</p></li><li><p>补码符号位拓展：</p></li></ul><p>  将n位定点整数补码拓展到2n位：</p><ul><li>当补码表示正数时，则直接在前面补上n个0即可</li><li>当补码表示负数时，则在前面补上n个1即可</li></ul><p>  即与符号位保持一致进行拓展</p><ul><li>算术右移（除2运算）</li></ul><p>一个数算术右移1位后，其最低有效位被移出。低位舍去，高位补符号位</p><p>小数 正数情况：低位舍去，高位补0</p><p>​负数情况：低位舍去，高位补1</p><ul><li>算术左移（乘2运算）</li></ul><p><strong>移码</strong>：</p><p>移码的值和真值成线性正比关系</p><p>无论正负数：补码求移码——符号位取反即可</p><p><strong>三种码的相互转换</strong>：</p><p>1、机器数是正数——符号位为0</p><p>原码&#x3D;反码&#x3D;补码</p><p>2、机器数是负数——符号位为1</p><p>反码&#x3D;原码（符号位除外）取反</p><p>补码&#x3D;反码末尾+1</p><p>无论正负数，移码&#x3D;补码符号位直接取反</p><p><a href="https://www.bilibili.com/video/BV1KP411X71M/?p=2&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.02.29 补码的性质2；反码、移码_哔哩哔哩 bilibili</a> 学习到了 0:28:04</p><p><strong>总结</strong>：</p><p>正数的原码，补码，反码<strong>相同</strong>；</p><p>负数的反码：原码的数值（符号位除外）取反；</p><p>负数的补码：原码转换成反码，反码末位加1</p><p>负数的移码：与补码的符号位取反</p><p>已知补码求原码：</p><p>最高位如果是1的话（负数），那么除了最高位之外的取反，然后加1得原码。</p><p>最高位如果是0的话，不变，正数的补码就是他的原码。<br>————————————————<br>版权声明：本文为CSDN博主「隔壁郑同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_44517301/article/details/93890346">https://blog.csdn.net/weixin_44517301/article/details/93890346</a></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><a href="https://www.bilibili.com/video/BV1KP411X71M?p=3&vd_source=9fb105320442648b8c6fe466cf6f8b5c">2020.03.04 浮点数的一般格式1</a></p><p>科学计数法：</p><ul><li>动态移动十进制小数点到约定位置，并使用10的指数来记录此小数点的位置</li><li>可表示整数也可表示小数</li><li>可表示范围很大</li><li>规格化数字</li></ul><img src="E:\DeskTable\博客学习截图传输\image-20230919092538911.png" alt="image-20230919092538911" style="zoom:50%;" /><p>数符：表示浮点数的符号</p><p>阶符：</p><p>阶码：（数值部分）从高位开始进行比较 阶码位数表示表示范围</p><p>尾数：（数值部分） 尾数位数越多，精度越高</p><p>所谓的浮点数表示其实可以简单粗暴的理解成，把一个数按照以2为模的科学计数法，将符号（+ -）放在首位——数符，将2^n以二进制形式放在前面——阶码，把数的部分以二进制码形式放在后面——尾数</p><p>但是二进制的尾数是纯小数形式，不需要小数点前有有效数字。</p><p>规格化的浮点数：</p><p>在计算机当中尾数的表示一般采取的是原码，但是补码也得了解了解</p><ul><li><p>如果阶码的底为2，则尾数应该满足 1&#x2F;2 &lt;&#x3D; |M| &lt; 1 —— 原码 小数点右侧第一位为1（0.1xxxxxxx……） </p></li><li><p>当尾数用补码表示：</p><ul><li><p>尾数M&gt;&#x3D;0时，尾数应当具有的格式：M &#x3D; 0.1xxxxx…x，$当M \geq 0 时，[\frac{1}{2}]_补 \leq [M]_补 &lt; [1]_补$</p></li><li><p>尾数M&lt;0时，不将$[-1&#x2F;2]_补$列入规格化的数，而把$[1]_补$列入规格化的数当中。</p></li><li><p>即: $[1&#x2F;2]_补 \geq [M]_补 \leq [1]_补 $</p></li></ul></li><li><p>左规：</p><p>采用变形补码表示尾数，则当结果的尾数出现11.11xxxx或00.0xxxx时，将尾数左移1位，阶码-1，直到尾数变为<strong>规格化</strong>形式为止</p></li><li><p>右规：  </p><p>当结果尾数出现01.xxxx……x或者10.xxx……x时，并不一定溢出，应当先把尾数右移一位，阶码+1，在判断阶码是否溢出</p></li></ul><h2 id="奇偶校验码："><a href="#奇偶校验码：" class="headerlink" title="奇偶校验码："></a>奇偶校验码：</h2><p>对于一个n位的信息，在最前面增加一个奇偶校验位，即通过这个增加的校验位来使得整个有效信息串当中的1的个数达到“奇数”——对应奇校验 或者“偶数”——对应偶校验</p><h3 id="方法局限性："><a href="#方法局限性：" class="headerlink" title="方法局限性："></a>方法局限性：</h3><p>当出现偶数个位数的错误时，则无法进行校验。</p><h3 id="奇校验："><a href="#奇校验：" class="headerlink" title="奇校验："></a>奇校验：</h3><p>整个校验码（有效信息位和校验位）当中“1”的个数位奇数</p><h3 id="偶校验："><a href="#偶校验：" class="headerlink" title="偶校验："></a>偶校验：</h3><p>整个校验码（有效信息位和校验位）当中“1”的个数位偶数</p><h3 id="校验："><a href="#校验：" class="headerlink" title="校验："></a>校验：</h3><p>使用<strong>异或运算</strong>操作进行偶校验，结果为0则未出错，结果为1则出错</p><h2 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h2><h2 id="（Arithmetic-and-Logic-Unit，ALU）"><a href="#（Arithmetic-and-Logic-Unit，ALU）" class="headerlink" title="（Arithmetic and Logic Unit，ALU）"></a>（Arithmetic and Logic Unit，ALU）</h2><img src="E:\DeskTable\博客学习截图传输\image-20230919213319875.png" alt="image-20230919213319875" style="zoom: 67%;" /><h2 id="IEEE745标准："><a href="#IEEE745标准：" class="headerlink" title="IEEE745标准："></a>IEEE745标准：</h2><p>尾数的格式：</p><p>规格化的原码表示—— S.1xxxxxx</p><p>规格化补码表示—— 正数：0.1xxxxxx负数：1.0xxxxxx</p><h2 id="二进制的乘法："><a href="#二进制的乘法：" class="headerlink" title="二进制的乘法："></a>二进制的乘法：</h2><p>Booth法和阵列乘法器以及除法</p><h3 id="补码的乘法运算规则："><a href="#补码的乘法运算规则：" class="headerlink" title="补码的乘法运算规则："></a>补码的乘法运算规则：</h3><img src="E:\DeskTable\博客学习截图传输\image-20230921184009102.png" alt="image-20230921184009102" style="zoom:50%;" /><p>补码的编码值按位展开得到真值，正数符号位权值为<strong>1</strong>，负数符号位权值为**-1**</p><h3 id="原码一位乘法："><a href="#原码一位乘法：" class="headerlink" title="原码一位乘法："></a>原码一位乘法：</h3><p>和手算一样</p><img src="E:\DeskTable\博客学习截图传输\image-20230923105803490.png" alt="image-20230923105803490" style="zoom:27%;" /><p>加法次数和相乘的两个原码的位数相同</p><h3 id="Booth法"><a href="#Booth法" class="headerlink" title="Booth法"></a>Booth法</h3><h4 id="时序逻辑电路图"><a href="#时序逻辑电路图" class="headerlink" title="时序逻辑电路图"></a>时序逻辑电路图</h4><p>无符号：Booth法的电路是时序逻辑电路，具有时钟信号控制</p><img src="E:\DeskTable\博客学习截图传输\image-20230922162220296.png" alt="image-20230922162220296" style="zoom:50%;" /><h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><h4 id="1）手算及单元电路"><a href="#1）手算及单元电路" class="headerlink" title="1）手算及单元电路"></a>1）手算及单元电路</h4><img src="E:\DeskTable\博客学习截图传输\image-20230923101554580.png" alt="image-20230923101554580" style="zoom: 30%;" /><h4 id="2）、定点无符号数阵列乘法器"><a href="#2）、定点无符号数阵列乘法器" class="headerlink" title="2）、定点无符号数阵列乘法器"></a>2）、定点无符号数阵列乘法器</h4><p>组合逻辑电路因为不需要根据时钟周期进行移位累加，所使用的时间会少于移位累加的方法</p><p><img src="E:\DeskTable\博客学习截图传输\image-20230922170428659.png" alt="image-20230922170428659"></p><img src="E:\DeskTable\博客学习截图传输\image-20230923101344400.png" alt="image-20230923101344400" style="zoom:30%;" /><h4 id="3）、有符号数的阵列乘法"><a href="#3）、有符号数的阵列乘法" class="headerlink" title="3）、有符号数的阵列乘法"></a>3）、有符号数的阵列乘法</h4><p>下图中的电路可以完美实现一个二进制数的求补操作，即——从右往左找到第一个<strong>1</strong>，之后的所有位按位取反</p><p>可通过图中电路图可以做到</p><ol><li>已知一个数的补码，求该数的绝对值</li><li>已知一个数的绝对值，求该数的补码</li></ol><img src="E:\DeskTable\博客学习截图传输\image-20230923102304075.png" alt="image-20230923102304075" style="zoom:25%;" /><img src="E:\DeskTable\博客学习截图传输\image-20230923102750917.png" alt="image-20230923102750917" style="zoom:26.5%;" /><h2 id="二进制的除法"><a href="#二进制的除法" class="headerlink" title="二进制的除法"></a>二进制的除法</h2><h3 id="1）、原码除法"><a href="#1）、原码除法" class="headerlink" title="1）、原码除法"></a>1）、原码除法</h3><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ol><li>前提条件<ol><li>除数 !&#x3D; 0 </li><li>定点纯小数时，被除数绝对值小于除数，商的结果位数与除数保持一致，则认为精度足够了 </li><li>定点纯整数时，被除数绝对值大于或等于除数</li></ol></li><li>商的符号&#x3D;&#x3D;被除数符号<strong>异或</strong>除数符号</li><li>商的绝对值&#x3D;&#x3D;被除数绝对值&#x2F;除数绝对值</li><li>将符号和绝对值拼接</li></ol><p>由手算引入逻辑实现</p><img src="E:\DeskTable\博客学习截图传输\image-20230923103943081.png" alt="image-20230923103943081" style="zoom:30%;" /><h3 id="2）、恢复余数法"><a href="#2）、恢复余数法" class="headerlink" title="2）、恢复余数法"></a>2）、恢复余数法</h3><img src="E:\DeskTable\博客学习截图传输\image-20230923105332402.png" alt="image-20230923105332402" style="zoom:29.5%;" /><p><img src="/%5Cimage/image.p" alt="Alt text"></p><h1 align=center> 存储体系结构 </h1><h1 id="Ch8-计算机存储体系结构"><a href="#Ch8-计算机存储体系结构" class="headerlink" title="Ch8 计算机存储体系结构"></a>Ch8 计算机存储体系结构</h1><h2 id="8-1-Basic-Concepts"><a href="#8-1-Basic-Concepts" class="headerlink" title="8.1 Basic Concepts"></a>8.1 Basic Concepts</h2><img src="E:\DeskTable\博客学习截图传输\image-20231010221402861.png" alt="image-20231010221402861" style="zoom: 33%;" /><img src="E:\DeskTable\博客学习截图传输\image-20231010222309462.png" alt="image-20231010222309462" style="zoom: 50%;" /><img src="E:\DeskTable\博客学习截图传输\image-20231010222624421.png" alt="image-20231010222624421" style="zoom:50%;" /><h3 id="存储器的不同特性"><a href="#存储器的不同特性" class="headerlink" title="存储器的不同特性"></a>存储器的不同特性</h3><ul><li>存储信息的介质，物质类型<ul><li>Semiconductor，半导体</li><li>Magnetic Surface，磁盘，磁带</li><li>Optical，光盘</li></ul></li><li>用途</li><li>信息的易失性&#x2F;非易失性</li><li>转移单位</li><li>存取方式<ul><li>随机——存取时间和物理地址无光，任一单元的读写所需时间相同</li><li>顺序</li></ul></li><li>读写功能</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul><li><p>内存(Primary Storage)：计算机中直接被处理器(Processor)访问的存储器，也称为主存（Main Memory）或内部存储器（Internal Memory）。</p><ul><li>内存可以存储当前运行的程序和数据，以供处理器使用。</li></ul></li><li><p>内存比起外部存储器：读写速度更快，容量小，价格高</p></li><li><p>内存的类型有很多，常见的有随机存取存储器（RAM）、只读存储器（ROM）、高速缓冲存储器（Cache）。</p><ul><li><p>随机存取存储器（Random Access Memory,RAM）是一种可读写的内存，也叫做主存。它可以随机地访问任何一个地址的数据，而不需要按照顺序。RAM是易失性的，也就是说，当断电时，它会丢失所有的数据。</p><ul><li>RAM有两种主要的子类：<ul><li>静态RAM（Staic Random Access Memory,SRAM）：不掉电，则内容不丢失</li><li>动态RAM（Dynamic Ranodm Access Memory,DRAM）<ul><li>同步DRAM（Synchronous DRAM,SDRAM）</li></ul></li></ul></li></ul></li><li><p>只读存储器（Read Only Memory,ROM）是一种只能读取的内存，也叫做固件。它通常用来保存一些不会改变的数据或程序，例如计算机启动时的基本输入输出系统（BIOS）。ROM是非易失性的，也就是说，当断电时，它不会丢失数据。</p><ul><li>ROM有三种主要的子类：<ul><li>可编程只读存储器（PROM）</li><li>可擦除可编程只读存储器（EPROM）</li><li>电子可擦除可编程只读存储器（EEPROM）</li><li>闪速（Flash） ：<ul><li>NOR</li><li>NAND</li></ul></li></ul></li><li>ROM当中存储有一段代码指令<strong>BIOS</strong>，作用：<ul><li>硬件自检</li><li>输入输出接口初始化</li><li>最后跳转到MM当中的引导扇区，以及操作系统的启动</li></ul></li></ul></li><li><p>高速缓冲存储器（Cache）是一种位于处理器和主存之间的高速内存，它可以缓存一些经常使用的数据或指令，以减少处理器访问主存的时间。</p><p>Cache是静态RAM（SRAM）制造的，它比动态RAM（DRAM）更快，但也更贵。</p><ul><li>Cache有多个级别，通常分为一级缓存（L1）、二级缓存（L2）和三级缓存（L3）。</li></ul></li></ul></li><li><p>主存的运作（作用）：</p><ul><li><p>Connection of the Memory to the Processor——连接存储器和处理器</p></li><li><p>Processor-Memory Interface</p><ul><li>[处理器-内存接口的主要目的是让处理器能够读取或写入内存中的数据，以执行指令或存储结果。](<a href="http://www.ee.ic.ac.uk/pcheung/teaching/ee2_digital/Lecture">http://www.ee.ic.ac.uk/pcheung/teaching/ee2_digital/Lecture</a> 13 - memory interface.pdf)</li><li>基本原理：当处理器需要访问内存时，它会将内存地址发送到地址总线上，然后通过一个解码电路来选择相应的内存芯片或设备。</li></ul></li><li><p>Read(Load) Operation</p><ul><li>将一个特定内存位置的数据副本读到处理器（Processor）</li><li>Processor： Load the address of the required memory location  into the MAR register and set the R&#x2F;W line to 1</li><li>Memory：Place the data from the addressed location onto the  data lines and confirm this action by asserting the MFC signal</li><li>Processor: Upon receipt of the MFC signal, the processor loads  the data on the data lines into the MDR register.</li></ul></li><li><p>Write(Store) Operation</p><ul><li>将一项信息从处理器传输到特定位置，销毁该位置先前的内容。</li><li>Processor： Load the address of the specific location into MAR and  load the data into MDR register. It also set the R&#x2F;W line to 0.</li><li>Memory：When the data have been written, it responses processor  with MFC signal.</li></ul></li></ul></li></ul><h3 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h3><ul><li><p>外存(Secondary Storage)：计算机中不能直接被处理器访问的存储器，也称为辅助存储器（Auxiliary Storage）或外部存储器（External Memory）。</p><ul><li><p>外存可以长期保存大量的数据或程序，以供计算机使用。</p></li><li><p>外存的速度比内存：读写速度慢，容量更大，价格更低。</p></li></ul></li><li><p>外存的类型有很多，常见的有硬盘（Hard Disk）、固态硬盘（Solid State Drive）、U盘（Thumb Drive）、SD卡（SD Card）、光盘（Optical Disc）等。</p><ul><li><p>硬盘（<strong>Hard Disk</strong>）是一种利用磁性材料记录数据的外存，也叫做磁盘。它由一个或多个金属盘片组成，每个盘片都覆盖了磁性材料。硬盘通过一个机械臂上的磁头来读写数据，磁头可以在盘片上移动到不同的位置。硬盘的容量很大，但是速度较慢，而且易受物理损坏。</p></li><li><p>固态硬盘（<strong>Solid State Drive</strong>）是一种利用闪存芯片记录数据的外存，也叫做闪存盘。它没有任何机械部件，因此速度很快，而且抗震性强。固态硬盘的容量较小，但是价格较高，而且有写入次数的限制。</p></li><li><p>U盘（<strong>Thumb Drive</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做USB驱动器。它可以通过USB接口连接到计算机上，实现数据的传输和存储。U盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。U盘的优点是方便携带和使用，缺点是易丢失和损坏。</p></li><li><p>SD卡（<strong>SD Card</strong>）是一种利用闪存芯片记录数据的便携式外存，也叫做安全数字卡。它可以通过SD卡插槽连接到计算机或其他设备上，实现数据的传输和存储。SD卡的容量和速度各有不同，但是都比U盘小得多。SD卡的优点是体积小巧和兼容性强，缺点是易损坏和丢失。</p></li><li><p>光盘（<strong>Optical Disc</strong>）是一种利用光学原理记录数据的外存，也叫做光学数字媒体。它由一个或多个塑料圆盘组成，每个圆盘都覆盖了一层反射材料。光盘通过一个激光头来读写数据，激光头可以在圆盘上移动到不同的位置。光盘的类型有很多，常见的有CD（Compact Disc）、DVD（Digital Versatile Disc）、BD（Blu-ray Disc）等。光盘的容量和速度各有不同，但是都比硬盘和固态硬盘小得多。光盘的优点是成本低廉和寿命长久，缺点是易刮花和损坏。</p></li></ul></li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li>MAR(Memory Address Register) 存储器地址寄存器</li><li>MDR(Memory Data Register) 存储器数据寄存器</li></ul><h3 id="存储单元和地址"><a href="#存储单元和地址" class="headerlink" title="存储单元和地址"></a>存储单元和地址</h3><ul><li><p>Word（字）：每一组固定大小的<strong>bit</strong>称为一个字。</p></li><li><p>Word Length（字长）：每个字的位数称为字长。它通常在16位到64位之间</p></li><li><p>Byte(字节)：$1 byte &#x3D; 8 bit$ byte是KB，MB，GB中的B。</p><ul><li>K: $2^{10},1024$  </li><li>M：$2^{20},1046576$ </li><li>G：$2^{30},1073741824$</li></ul></li></ul><p>计算机存储器图表表示：</p><p><img src="E:\DeskTable\博客学习截图传输\image-20231010165617847.png" alt="image-20231010165617847"></p><p>大端赋值</p><h3 id="字节排序"><a href="#字节排序" class="headerlink" title="字节排序"></a>字节排序</h3><p>多字节数据类型（如整数、浮点数等）在内存中的字节排列顺序。它决定了在内存中的哪个字节存储数据的最低有效位（低位）和最高有效位（高位）。字节排序有两种常见的方式：大端序（Big-endian）和小端序（Little-endian）。</p><h4 id="大端赋值（Big-Endian）"><a href="#大端赋值（Big-Endian）" class="headerlink" title="大端赋值（Big-Endian）"></a>大端赋值（Big-Endian）</h4><ul><li>在大端字节顺序中，最高有效字节（Most Significant Byte，MSB）位于内存地址的最低端（低地址端）</li><li>最低有效字节（Least Significant Byte，LSB）位于内存地址的最高端（高地址端）。</li><li>这意味着在大端字节顺序下，数据的各个字节按照从高位到低位的顺序存储，与日常习惯从左到右读数的顺序相同。</li></ul><p><a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">大端赋值（从左到右）是一种在内存中存储数据的方式，其中最高有效字节（MSB）放在最低的内存地址，而最低有效字节（LSB）放在最高的内存地址。这意味着字节的存储顺序与我们从左到右读取它们的顺序相同。</a> </p><p>例如，如果我们想要将十六进制数 0x12345678 存储在一个 4 字节的内存位置，我们将按照以下方式分配字节：</p><table><thead><tr><th align="left">内存地址</th><th align="left">字节值</th></tr></thead><tbody><tr><td align="left">0x1000</td><td align="left">0x12</td></tr><tr><td align="left">0x1001</td><td align="left">0x34</td></tr><tr><td align="left">0x1002</td><td align="left">0x56</td></tr><tr><td align="left">0x1003</td><td align="left">0x78</td></tr></tbody></table><p><a href="https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/">这也被称为大端字节序或网络字节序，因为它通常用于网络协议，如 TCP&#x2F;IP。</a> </p><p>大端赋值的一些优点是：</p><ul><li><a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">它更容易阅读和调试，因为数据的存储顺序与我们写它的顺序相同。</a></li><li><a href="https://teaching.idallen.com/cst8281/10w/notes/110_byte_order_endian.html">它与我们在数学中表示数字的方式一致，其中最高有效位在左边。</a></li><li><a href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它简化了算术运算，如加法和减法，因为进位或借位从右到左传播。</a></li></ul><p>大端赋值的一些缺点是：</p><ul><li><a href="https://stackoverflow.com/questions/26204333/little-endian-and-big-endian">它与一些使用小端赋值的处理器不兼容，其中 LSB 在最低的内存地址，而 MSB 在最高的内存地址。这在不同系统之间交换数据时可能会导致问题。</a></li><li><a href="https://electronics.stackexchange.com/questions/608853/does-declaring-verilog-arrays-with-indices-in-different-directions-makes-any-dif">它在处理数组或矩阵时可能会引起混淆，因为索引顺序可能与字节顺序不匹配。例如，在 Verilog 中，一个声明为 <code>reg [3:0] array1 [0:7]</code> 的数组具有大端位顺序，但小端索引顺序。</a></li></ul><h4 id="小端赋值"><a href="#小端赋值" class="headerlink" title="小端赋值"></a>小端赋值</h4><ul><li>在小端序中，最低有效字节（低位字节）存储在内存的最低地址。</li><li>最高有效字节（高位字节）存储在内存的最高地址。</li><li>这种字节排序方式类似于我们书写数字的方式，从右到左。</li><li>小端序在一些体系结构（如x86、ARM、网络通信协议中的小端序）中使用。</li></ul><h2 id="8-6-Cache-Memories"><a href="#8-6-Cache-Memories" class="headerlink" title="8.6 Cache Memories"></a>8.6 Cache Memories</h2><p>Main Memory的一个块只能映射到Cache固定的一行当中，</p><h3 id="Cache-Hit"><a href="#Cache-Hit" class="headerlink" title="Cache Hit"></a>Cache Hit</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
